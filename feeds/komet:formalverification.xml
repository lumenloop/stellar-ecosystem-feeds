<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
  <title type="text">Stories by Runtime Verification on Medium</title>
  <link rel="alternate" type="text/html" href="https://medium.com/@runtimeverification?source=rss-501a37f020aa------2"/>
  <link rel="self" type="application/atom+xml" href="http://10.0.0.124:3044/?action=display&amp;bridge=FeedFinderBridge&amp;url=https%3A%2F%2Fruntimeverification.medium.com%2F&amp;strip=on&amp;_cache_timeout=3600&amp;format=Atom"/>
  <icon>https://cdn-images-1.medium.com/fit/c/150/150/1*GAVjSkYTPGgxA4eKeejYIg.png</icon>
  <logo>https://cdn-images-1.medium.com/fit/c/150/150/1*GAVjSkYTPGgxA4eKeejYIg.png</logo>
  <id>http://10.0.0.124:3044/?action=display&amp;bridge=FeedFinderBridge&amp;url=https%3A%2F%2Fruntimeverification.medium.com%2F&amp;strip=on&amp;_cache_timeout=3600&amp;format=Atom</id>
  <updated>2025-04-11T22:07:02+00:00</updated>
  <author>
    <name>RSS-Bridge</name>
  </author>
  <entry>
    <title type="html">Kontrol updates April 4t, 2024</title>
    <published>2024-04-04T18:32:59+00:00</published>
    <updated>2024-04-04T18:32:59+00:00</updated>
    <id>https://runtimeverification.medium.com/kontrol-updates-april-4t-2024-5e5af2e789c8?source=rss-501a37f020aa------2</id>
    <link rel="alternate" type="text/html" href="https://runtimeverification.medium.com/kontrol-updates-april-4t-2024-5e5af2e789c8?source=rss-501a37f020aa------2"/>
    <author>
      <name>Runtime Verification</name>
    </author>
    <content type="html">Today, we are introducing a new way to bring updates!From now on, we will publish weekly updates and each week, we will dive into different topics and tools!Let’s start with Kontrol:Added proof execution time to the output of `kontrol prove`: we now record how long it took each proof to execute and show this information in the default output of `kontrol prove` as well as `kontrol view`.Implemented `hevm` success predicate in addition to the `foundry_success` one that is used by default. It can be enabled by an ` — hevm` option available in `kontrol prove`. According to this success predicate, only failed `assert` and `DSTest` assert expressions constitute a test failure, as opposed to `foundry` success predicate that includes revert into the list of failure reasons. The details are available at https://github.com/runtimeverification/kontrol/blob/master/src/kontrol/kdist/hevm.md.Updated UX for `kontrol view-kcfg` and `kontrol show` commands. Now, the latest proof is loaded by default if no ` — version` option is provided, and a warning message is displayed. In addition, to assist the user, we refactored an error message that is shown if there are multiple proofs that can be selected — we now print the names of all available proofs for the user to select and copy one of them.Based on user feedback, we refactored NatSpec tags for dynamically sized arguments in functions: now, the number of elements in the `vaults` array can be specified as `/// @custom:kontrol-array-length-equals vaults: 4`, and the length of `bytes vaultData` — as ` /// @custom:kontrol-bytes-length-equals vaultData: 256`.Implemented `kontrol split-node` command, which allows manually splitting a node on a user-provided branching condition. This feature is useful, for example, for introducing assumptions without having to restart a proof, by splitting a node on the assumption and then refuting (i.e., delaying the execution of) the negative branch.Added JUnit XML report generation for `kontrol prove` results. A report is generated if `kontrol prove` is ran with ` — xml-report` option. This feature is aimed at providing more advanced result and test reporting and is particularly useful when running Kontrol in CI, as JUnit XML reports are widely used in CI tools.Added ` — cse` flag for `kontrol prove` that enables compositional symbolic execution. With this option, when Kontrol executes a function `a()` that calls another function `b()`, it will first execute `b()` and build a summary for it. It will then re-use this summary when `b()` is called within `a()` or any other function instead of re-executing it every time.To facilitate debugging with Simbolik, we introduced ` — with-non-general-state` option to `kontrol prove`. By default, when `kontrol prove` is ran on a non-test (e.g., a function that does not start with `test`, `prove`, or `check`), the initial state is kept largely symbolic to allow for symbolic exploration of all possible behaviors. With this option, initial state has a similar configuration that Kontrol uses when executing symbolic tests and is, therefore, less general.That’s all for this week’s updates on Kontrol! We will be back next week with more updates for ERCxIf you have questions about Kontrol or other topics, you can talk directly with our team in Discord.</content>
  </entry>
  <entry>
    <title type="html">Kontrol 101</title>
    <published>2024-04-01T11:13:29+00:00</published>
    <updated>2024-04-01T11:13:29+00:00</updated>
    <id>https://runtimeverification.medium.com/kontrol-101-04459131b438?source=rss-501a37f020aa------2</id>
    <link rel="alternate" type="text/html" href="https://runtimeverification.medium.com/kontrol-101-04459131b438?source=rss-501a37f020aa------2"/>
    <author>
      <name>Runtime Verification</name>
    </author>
    <content type="html">Recently you may have heard about our new tool Kontrol, but are still uncertain about what it is or how it might benefit your project’s security. This blog post addresses those concerns by explaining the blockchain security lifecycle, how it differs from traditional software security, and the role that Kontrol plays in ensuring that your application is as secure as possible.Why Should I Care About the Security Lifecycle?There is one product development truth that haunts most software projects: there is never enough time for testing, resulting in live applications which have not been properly tested. Most developers perform unit testing to verify basic functionality and then move on to the next project. Those that are fortunate enough to have a QA department to perform more rigorous testing generally fare better, but in the end, most products hit the market under-tested, resulting in fixing problems after the application is already in production.For most applications, the consequences are manageable (poor performance, sub-optimal user experience, lost revenue, etc.). However, in the case of blockchain applications, code vulnerabilities can be exploited by malicious actors, resulting in significant financial losses for project stakeholders. Blockchain ecosystems are inundated daily with new exploits against poorly tested code, resulting in billions of dollars in lost value. These attacks can be minimized or avoided altogether through better security practices during the software development lifecycle. Properly protecting smart contracts requires advanced development and testing techniques, including security focused code reviews, enhanced unit and integration testing, property testing, fuzz testing, and even formal methods such as symbolic execution.The challenge with these advanced testing techniques is that they typically require significant expertise that most developers and QA teams do not possess. The current accepted industry practice consists of protocol development teams performing as much testing as possible before passing the application to a third party for an audit prior to deploying it on-chain. The trouble here is that not all auditors are created equal; most only do a manual code review, find a few errors, and provide a report saying the code is ready for production. If you are fortunate enough to find an auditor skilled in formal methods you will likely achieve a more consistent, reproducible and more secure result, but even this best practice results in several challenges along the way:Under-tested code contains more vulnerabilities that must be fixed and re-auditedMany projects go through several lengthy audit cycles before being ready for mainnetPoor auditor expertise resulting in missed exceptions and exploitable vulnerabilitiesIn virtually every case where multiple auditors are used, results vary with each reportRelying on a “one size fits all” security audit process often leaves code vulnerableCoupling these issues with the pressure to get the project to market as fast and economically as possible generally results in a common phenomenon across the industry: do as little rework as possible to “pass” the audit, convince yourself that any remaining exceptions a “not a big deal”, promote to mainnet, and hope for the best.Just Passing an Audit Shouldn’t Be the GoalThere is another way.Ideally, developers should practice as much of the aforementioned security cycle as possible before submitting their code for a security audit. To do this effectively, teams should conduct security focused design and code review processes, as well as employ more formal testing methods beyond simple unit testing. Extending testing to include property testing, fuzz testing, and ultimately symbolic execution provides better confidence that a security audit will be successfully executed in an expeditious timeframe. These techniques are briefly described below, but there are volumes of information available dedicated to each:Unit TestingUnit testing is a software testing technique where individual components or units of software, such as functions or methods, are tested in isolation to verify that each part functions correctly. Unit testing is an essential part of the development lifecycle, helping developers identify and fix bugs early in the development process. At the same time, unit tests are traditionally designed to check specific, predefined cases, focusing on expected inputs and use cases. This narrow scope of analysis can miss unexpected or edge case inputs that other techniques discussed later in the post are more likely to uncover.Property TestingProperty testing is a methodology in which tests are generated using a specified distribution based on a set of properties which the code should satisfy. Property tests are specified using logical properties which are automatically executed in search of counterexamples that show cases where these properties are violated. By testing these properties against a large number of randomly generated inputs, developers can identify potential edge cases and bugs that they may not have considered in their traditional unit tests.Fuzz TestingFuzz Testing, also known as fuzzing, is a dynamic software testing technique that involves providing invalid, unexpected, or random data as inputs to a software program. The primary goal is to discover software vulnerabilities, crashes, or other unexpected behaviors. Similar to Property Testing, the difference centers around the level of knowledge required to generate the inputs for testing. Fuzzing is typically a “black box” method where inputs are fully generalized, whereas Property Testing shapes the test inputs to “interesting” ranges derived from the code under test.Symbolic TestingSymbolic testing, the practice of running tests with symbolic inputs, is an effective formal verification method that reduces specification overhead. This approach enables the use of the same test cases for both testing and formal verification. Unlike traditional testing, which verifies that a program works correctly for a limited set of inputs, symbolic testing checks the program for all possible inputs, hence a program that passes symbolic testing can be considered formally verified.What is Kontrol?Formal verification attempts to solve a challenging problem, but a common misconception is that it is too time consuming to use in practice. The real problem is that most formal verification tools require users to work with multiple specification languages to describe the properties that should hold during execution, thus making it more complicated than it needs to be.Kontrol was built with developers and auditors in mind, giving them the ability to build and execute tests using languages and tools already familiar to them. Ethereum developers can build tests using Solidity rather than having to learn a new specification language, or build a completely new set of specifications for formal verification. Furthermore, Kontrol provides a way to symbolically execute existing Foundry tests, which can be augmented with additional verification-specific cheatcodes.By combining KEVM (RV’s formalized semantic of the Ethereum Virtual Machine) and Foundry, Kontrol grants developers and auditors the ability to perform formal verification without having to learn a new language or how to use new tools, which is particularly useful for people who are not verification engineers. By using Kontrol throughout the software development lifecycle, code vulnerabilities can be addressed before deploying to mainnet, ensuring application security at product launch.Once the project is live, Kontrol can be used to validate subsequent evolutions of the codebase and ensure that changes do not adversely impact security. K as a Service (KaaS) can even be used to integrate symbolic execution into an application’s continuous integration processes, effectively validating code security on every iteration of the application. Runtime Verification recently worked with Optimism to validate changes to their codebase before merging them into production.Why Do I Need Kontrol?While fuzzing is a powerful testing technique, and a considerable step up from the unit testing employed by most developers, it still has limitations that motivate the need for a complementary symbolic execution of the test suite. Due to pseudo-random input generation, fuzzing struggles to generate input values for complex or nested conditions. Symbolic execution systematically explores all feasible code paths by using symbolic variables as input and tracking path conditions, thus providing more comprehensive coverage.Additionally, symbolic execution can automatically derive and check postconditions, providing stronger guarantees on the correctness of the program. These complementary approaches can be used to identify a wider range of bugs and vulnerabilities, leading to more reliable software.By installing Kontrol, you unlock the capability to perform property verification. This is a big step up in assurance from property testing, but is more computationally expensive, and often requires manual intervention.A Practical ExampleTo illustrate the value of Kontrol (and symbolic execution in general), first consider the following code example (if you want to run this example yourself it may be found in our Kontrol documentation):The contract `Counter` has a public variable named `number` that is either set to a specific value by the method `setNumber(uint256)`, or incremented by `increment()`. The `setNumber` function will update the storage variable with the passed value unless `newNumber` is `0xC0FFEE` and the variable `inLuck` is `true` — in this case, the function will revert.The next step is to write a test for this contract:In this example, the `testSetNumber` test should pass nearly every time. Consequently, when using a fuzzing tool such as Foundry’s Forge, whether or not this test passes depends on the inputs generated during a fuzzing campaign. If the inputs `x = 0xC0FFEE` and `inLuck = true` are generated by Forge, then the test will fail; otherwise it will pass. In a vast majority of cases, this bug is not found.Property verification in Kontrol allows you to catch errors that fuzzing in Forge might miss. Kontrol compiles the source and testing files with `forge build` under the hood, so there is no need to call it explicitly. Once compiled, it inspects the artifacts generated and produces the KEVM helper modules (rules for ABI properties, bytecode, etc.) for the contracts being tested, as well as the definition necessary to execute the tests symbolically.Through symbolic execution, Kontrol explores every possible variable combination through the `Counter` contract as defined in `CounterTest`, and after three minutes or so the test will revert, producing a counterexample exhibiting that the values `x = 0xC0FFEE` (`12648430` in decimal format) and `inLuck = true` result in a failure.As a matter of good practice, Runtime Verification recommends fuzz testing your contract first in order to quickly identify errors that must be corrected. Once the code passes fuzz testing, Kontrol should be used with the same set of tests for exhaustive input coverage in order to catch even the most unlikely of edge-cases.Get in Touch With Us!Kontrol is actively being developed and evolving as a tool. We are actively looking for feedback from users and security experts. Should you have any suggested improvements or features that would improve Kontrol or to integrate it into your development and testing processes, please contact us.</content>
  </entry>
  <entry>
    <title type="html">Runtime Verification February 2024 Updates</title>
    <published>2024-03-05T18:41:46+00:00</published>
    <updated>2024-03-05T18:41:46+00:00</updated>
    <id>https://runtimeverification.medium.com/runtime-verification-february-2024-updates-f30ddcae9216?source=rss-501a37f020aa------2</id>
    <link rel="alternate" type="text/html" href="https://runtimeverification.medium.com/runtime-verification-february-2024-updates-f30ddcae9216?source=rss-501a37f020aa------2"/>
    <author>
      <name>Runtime Verification</name>
    </author>
    <content type="html">Welcome to another issue of our monthly newsletter on Medium. This time around, we bring our updates for the month of February. If you want to be up to date with what we are up to, follow us on X or join our Discord to get in touch with our team and ask them all your questions about our work and tooling.EVENTSPart of our team is currently in Denver, attending ETHDenver and all the side events organized around the main event. Grigore Rosu, our CEO, participated in a series of side events talking about Pi Squared and ZK technology. Those side events include Scale Summit (hosted by Nil Foundation and LambdaClass), Encode Club and StarkCity (hosted by StarkWare). Stay tuned to the next newsletter issue for the video recordings from the events we participated in.Grigore at Encode ClubBLOG POSTSOur ERCx team has been working hard on shipping updates and writing a series of blog posts diving deep into the tool’s potential. This month, we published the second part of Testing ERC-20 Tokens: Advancing Benchmarking with Mutation Testing. Before looking at this blog, make sure to read the first part of this series: An Arsenal for Bug Detection.AUDITSOur team is working on reviewing code for various projects we will announce soon. One of our latest completed and published audits is the Synonym Finance protocol. As always, we have published a technical report and a blog post that can be viewed by anyone interested to know more about what went down during the audit.KONTROLThese are the monthly updates from our team working on Kontrol:To further facilitate verification of Solidity tests, we added support for function parameters of dynamic types in the calldata — such as `bytes` and `bytes[]` — as well as support for NatSpec comments that can be used to provide assumptions about the length of dynamically typed variables. For example, the following test can now be automatically verified by Kontrol:```    struct ComplexType {        uint256 id;        bytes content;    }    /// @custom:kontrol-length-equals content: 10000,    /// @custom:kontrol-length-equals ba: 10,    /// @custom:kontrol-length-equals ba[]:600,    function test_complex_type(ComplexType calldata ctValues, bytes[] calldata ba) public {        require (ba.length == 10, &amp;quot;DynamicTypes: invalid length for bytes[]&amp;quot;);        assert(ctValues.content.length == 10000);        assert(ba[8].length == 600);    }```The NatSpec comments labeled with the `@custom:kontrol-length-equals` tag indicate that `bytes content` is 10000 bytes long, while the `bytes[] calldata ba` array has 10 element, each 600 bytes long.Added `kontrol refute-node` and `kontrol unrefute-node` commands. `kontrol refute-node` interrupts an invalid execution path so that it can be disproved later (via `kontrol unrefute-node`). This functionality lets the user control the exploration without having to restart execution. That way we, can identify invalid paths early and have the tool focus on the other ones for increased efficiency, while the user figures out what they need to do to ultimately remove those invalid paths completely.Introduced a new Kontrol cheatcode: `kevm.freshBytes(uint256 length)`, which allows a user to generate a fresh symbolic bytes array of a given size, making Kontrol tests more expressive and flexible.Updated the logic of verified test selection if no ` — match-test` is provided: now, `kontrol prove` would automatically verify all tests that are located in the `/out` folder of a Foundry project and start with `test`, `prove`, or `check` keywords.Renamed the `kontrol summary` command to `kontrol load-state-diff`, which is our new feature that allows generating a summary for a Solidity function based on the list of account accesses that is generated by Foundry.Implemented support for Foundry’s `mockCall` cheatcode — it now can be used in Kontrol tests to mock calls to an address with a particular call (and return) data: `function mockCall(address where, bytes calldata data, bytes calldata retdata) external;`.K FRAMEWORKWe also bring some updates regarding our K efforts:Focus on documenting and simplifying the behavior of the K language and compiler.Many historic dark corners have been cleaned up to substantially improve the K tutorials and learning experience in a future release.ERCxAnd, before wrapping up this month’s newsletter, here are the ERCx updates:Launched a test suite for ERC-721 tokens, aka NFTs! To know more about tested properties, please refer to our What’s being tested page.Added Explorer and Uniswap Top Tokens from several Layer 2 chains.Expanded 4626 Alliance Vaults to include vaults from several Layer 2 chains.Added detectors for new ERC standards: ERC-165, 223, 721, 777, 1271, 1363, 1820, 2309, 2612, 2771, 2981, 4524, 4906, 5267, 5313, 5805 and 6372.Based on the valuable feedback from our users, we simplified our test levels to the following four: Abi (Signature), Standard, Security, and Features.Updated our VSCode extension to support the ERC721 test suite and the updated test levels.As usual, we would love to hear your feedback on the above! In particular, please let us know which standard you want a test suite or a detector for.That’s all for this month’s updates. Join us on X and Discord to never miss any updates from us.</content>
  </entry>
  <entry>
    <title type="html">Runtime Verification January 2024 Updates</title>
    <published>2024-02-05T19:04:21+00:00</published>
    <updated>2024-02-05T19:04:21+00:00</updated>
    <id>https://runtimeverification.medium.com/runtime-verification-january-2024-updates-99b04fadc472?source=rss-501a37f020aa------2</id>
    <link rel="alternate" type="text/html" href="https://runtimeverification.medium.com/runtime-verification-january-2024-updates-99b04fadc472?source=rss-501a37f020aa------2"/>
    <author>
      <name>Runtime Verification</name>
    </author>
    <content type="html">Welcome to the first newsletter of the year. This time around, we bring a combination of updates from last December and the month of January. If you want to be up to date with what we are up to, follow us on X or join our Discord to get in touch with our team and ask them all your questions about our work and tooling.AUDITSOur team has been working on some long-term engagements with clients during the past two months, including our latest report and blog post on MultiversX’s Multi Asynchronous Calls audit. In the upcoming weeks, we will announce newly completed audits and engagements on our X account, and they will be added to the next newsletter issue.KONTROLThese are the monthly updates from our team working on Kontrol:Implemented `kontrol summary` — a new feature that allows to generate a summary for a Solidity function based on the list of account accesses that is generated by Foundry. This feature is particularly useful in projects with complicated and lengthy deployment — in this case, the execution of `setUp()` can be summarized via `kontrol summary`; then, the generated JSON file containing the summary of a deployment process can be used to initialize the initial node of the KCFG, i.e., the state of the contract at the start of verification, possibly saving tens of minutes of execution time (PRs: https://github.com/runtimeverification/kontrol/pull/271, https://github.com/runtimeverification/kontrol/pull/221).Added `no-gas` execution mode in `kontrol prove`, which is now the default behavior. With this change, Kontrol does not compute or reason about gas costs, which speeds up the execution. Gas computation can be turned on via the ` — use-gas` option now available in `kontrol prove` (PR: https://github.com/runtimeverification/kontrol/pull/252).Enabled Foundry test-like verification for tests starting with `check`,` prove`, `checkFail`, and `checkProve` prefixes, in addition to previously supported `test` and `testFail`. Such tests are being checked for failures caused, e.g., by failed `assert` and `require` statements, compiler-inserted overflow checks, and so on. This update allows specification of Kontrol-specific tests that would not be picked up for fuzzing during a `forge test` run, and provides compatibility with other symbolic testing tools such as halmos and hevm. Functions that do not start with one of these prefixes will be symbolically executed by `kontrol prove`, but any such failures will not be reported (PR: https://github.com/runtimeverification/kontrol/pull/249).Turned on ` — no-break-on-calls`, ` — fail-fast`, and ` — counterexample-generation` options in `kontrol prove` to improve the default performance and UX of the tool. As a result of this change, by default, Kontrol will not save a new node in KCFG every time an EVM call is performed, it will stop the execution on other branches if a failure has been identified in one of them, and will output the counterexample(s) for the failing test. These options can be turned off via ` — break-on-calls`, ` — no-fail-fast`, and ` — no-counterexample-generation`, respectively. (PR: https://github.com/runtimeverification/evm-semantics/pull/2258)Added ` — break-on-basic-blocks`, ` — break-on-storage`, and ` — break-on-cheatcodes` options to `kontrol prove`, instructing it to add a new node for every basic block, `SSTORE/SLOAD` operation, and Foundry rules and KEVM, thereby generating a more detailed KCFG and making it is easier to explore and investigate (PRs: https://github.com/runtimeverification/kontrol/pull/261, https://github.com/runtimeverification/evm-semantics/pull/2246, https://github.com/runtimeverification/evm-semantics/pull/2242).Enabled generation of KEVM claims from Kontrol-produced KCFG to facilitate debugging and profiling of proofs and claims. Option ` — to-kevm-claims` to “kontrol show …` now produces a module containing KEVM claims for each basic block. Option ` — kevm-claim-dir` … allows specifying a directory to generate these claims in. (PR: https://github.com/runtimeverification/kontrol/pull/262).Added support for `struct` variables in analyzed test function parameters to make it even easier to verify tests from an existing Foundry test suite (PR: https://github.com/runtimeverification/kontrol/pull/78)Modified internal K representation of analyzed contracts in include an absolute path in the name of the contract, making it possible to disambiguate (and, therefore, execute correctly) same-name contracts within one project (PR: https://github.com/runtimeverification/kontrol/pull/219).Included useful lemmas on boolean reasoning, set reasoning and map lookup to KEVM, facilitating and streamlining the analysis of EVM smart contracts (PRs: https://github.com/runtimeverification/evm-semantics/pull/2037, https://github.com/runtimeverification/evm-semantics/pull/2251).RESEARCHThis month, we also bring an exciting update from our research team:Our paper, “A Logical Treatment of Finite Automata”, was accepted for the TACAS 2024 conference. In this paper, we show that by capturing finite automata as matching logic formulae, we may also capture algorithms that manipulate them. In fact, we are able to produce complete Hilbert-style proofs for equivalence between regular expressions using this technique. This is a first step towards formally proving similar manipulations over a program control flow graph, and other transition systems.ERCxAnd, before wrapping up this month’s newsletter, here are the ERCx updates:Added support for some Layer 2 networks such as Optimism (Mainnet and Sepolia), Arbitrum (Mainnet, Nova and Sepolia), Polygon (Mainnet and Mumbai), Binance Chain (Mainnet and Testnet), Linea (Mainnet), and Base (Mainnet and Sepolia).We released the first version of our test suite for ERC-721 tokens, aka NFTs.Cranked out the final version of our ICST 2024 paper on Leveraging Mutation Testing to Improve and Minimize Test Suites for Smart Contracts. This is a collaborative work with Certora Inc.Following the kind feedback from the auditors we met, we merged test levels Minimal and Recommended into Conformance. Conformance tests comprise all properties extracted from the standard.We brought several improvements to our backend.That’s all for this month’s updates. Join us on X and Discord to never miss any updates from us.</content>
  </entry>
  <entry>
    <title type="html">Runtime Verification November 2023 Updates</title>
    <published>2023-12-04T18:22:00+00:00</published>
    <updated>2023-12-04T18:22:00+00:00</updated>
    <id>https://runtimeverification.medium.com/runtime-verification-november-2023-updates-c16cfc405363?source=rss-501a37f020aa------2</id>
    <link rel="alternate" type="text/html" href="https://runtimeverification.medium.com/runtime-verification-november-2023-updates-c16cfc405363?source=rss-501a37f020aa------2"/>
    <author>
      <name>Runtime Verification</name>
    </author>
    <content type="html">Welcome to another issue of our monthly newsletter on Medium. This time around, we bring our updates for the month of November. As always, the updates that we post here are summarized and simple, but we are more than happy to give more details and answer any questions on our Discord server.EVENTSThe month of November has been a busy one attending and speaking at events, so let’s get into all the events our team took part in:Palina Tomach had the pleasure of joining Patrick Collins on the Cyfrin Audits YouTube channel to talk about Formal Verification and Kontrol.https://medium.com/media/e734da89c4295271ddf68f7c4eba81b6/hrefA part of our team traveled to Istambul to attend DevConnect and speak at some of the events organized by the community, including TrustX, EVM Summit, Alt Layer Frontier Day and Nethermind Summit. Last week, we published a blog post with our participation in those events and a summary of the topics and we also published a Twitter thread with a shorter version of the blog.https://medium.com/media/fa2b6bdb8f8e09d80780415b3dc89c65/hrefhttps://medium.com/media/ca2bdb4269ce52a02bf1585ec4691671/hrefhttps://medium.com/media/64af6c4d761f9c49d30b32cae56f8864/hrefRikard Hjort attended the Urbit Assembly in Lisbon and moderated a panel discussion on how to make Urbit secure and what a secure Urbit looks like. Panel participants included Urbit experts Logan Allen, and Joe Bryan and cybersecurity expert Ryan Lackey. Rikard also presented our work on %quiz at Urbit Demo DayYlies Falcone joined the BeerFi meetup in Prague to share with the audience about ERCx. No recording is available for this talk but you can check our other ERCx talks and resources.BLOG POSTSIn November, we published a new blog post announcing KMIR, a concrete and symbolic execution of Rust MIR. The blog shows a tutorial on how to extract MIR from the Rust compilation process and how to execute MIR programs with KMIR. We also would like to thank The Web3 Foundation again for the grant received to develop the syntax and semantics of Rust MIR.KONTROLThese are the monthly updates from our team working on Kontrol:Added ` — no-forge-build` option that helps skip the `forge build` step in `kontrol build` and use pre-compiled artifacts instead — this way, the user can call `forge build` with options they need prior to `kontrol build`.Improved help messages and support for backend- and SMT-related options in Kontrol. `kontrol prove`, `kontrol simplify-node`, `kontrol step-node`, `kontol section-edge`, and `kontrol get-model` commands now all have access to options that help customize the interaction with the backend RPC server and the SMT solver, such as ` — use-booster`, ` — kore-rpc-command`, ` — trace-rewrites`, ` — port`, ` — maude-port`, ` — bug-report`, ` — smt-timeout`, ` — smt-retry-limit`, ` — smt-tactic`. Detailed information on these options is available via `kontrol — help`.Improved Kontrol source files organization by moving cheatcode definitions to a separate file cheatcodes.md.Improved handling of the `expectRevert` cheatcode, which helps ensure that the function call reverted during its execution.Added the `.` symbol to the list of characters being escaped in contract names during `kontrol build` — now, smart contracts containing `.` in their names can be kompiled successfully for further verification with Kontrol.Fixed a bug with `block.number` value not being carried over from `setUp()` function — now, the value set via the `vm.roll(uint256)` cheatcode in `setUp()` is respected in the following tests.K FRAMEWORKWe also bring some updates regarding our K efforts:Released K v6.1.0. This contains cumulated changes over the past five months where we continued to improve the performance of the kompiler and the prover. We also updated dependencies that allowed us to bring native support to Apple Silicon. As a result, we dropped support for Ubuntu 20.04 Focal and we will change our focus to the upcoming release of Ubuntu 24.04. We strive to provide support for the last two LTS of the major platforms.ERCxAnd, before wrapping up this month’s newsletter, here are the ERCx updates:Some features and parts of the token reports now require creating an account.Added tests for the ERC-4626 vault tokens and updated of our VS Code plugin to support them.Revamped token reports for a better experience.That’s all for this month’s updates. Stay tuned and join us on Discord so you don’t miss any news from us.</content>
  </entry>
  <entry>
    <title type="html">Devconnect week event recap: TrustX, Alt Layer Rollup Frontier Day, EVM Summit, and more</title>
    <published>2023-11-27T17:56:06+00:00</published>
    <updated>2023-11-27T17:56:06+00:00</updated>
    <id>https://runtimeverification.medium.com/devconnect-week-event-recap-trustx-alt-layer-rollup-frontier-day-evm-summit-and-more-3bb9187c6d0d?source=rss-501a37f020aa------2</id>
    <link rel="alternate" type="text/html" href="https://runtimeverification.medium.com/devconnect-week-event-recap-trustx-alt-layer-rollup-frontier-day-evm-summit-and-more-3bb9187c6d0d?source=rss-501a37f020aa------2"/>
    <author>
      <name>Runtime Verification</name>
    </author>
    <content type="html">After a long week in Istanbul for Devconnect, our team is back home working towards a safer ecosystem for projects and users alike with the new sets of tooling we are currently developing and that we presented in various events at Devconnect. In this short blog, we are going to summarize the topics presented at different community events during the week, what those events were about, and share any resources and video recordings currently available. But before we get into it, we want to thank the Devconnect team and all the event organizers for the fantastic events they put together for the community and for giving us a space to share our work with the audience.Pi² at Alt Layer Rollup Frontier DayOur newest project under development is Pi², a universal proof system solution to efficiently and correctly verify the execution of any program in any programming or virtual machine (VM) language. It uses zero-knowledge (ZK) technology in a correct-by-construction and fundamentally unique way, which allows a universal and disarmingly small ZK circuit to provide verifiable compute and formal verification correctness guarantees to all languages and VMs alike, without any translation to a common language, VM or ISA. Pi² makes blockchain/language/application inter-operability seamless and completely eliminates the need for traditional, yet notoriously buggy language implementations such as compilers, transpilers, or interpreters. Pi² builds on top of recent advancements in zero-knowledge proofs, formal semantics and logic reasoning techniques. Although Pi² captures both verifiable compute and formal verification as special functional fragments, it allows unprecedented combinations of them while maintaining verifiable compute completely automatic: formal verification can improve the performance of verifiable computing, which is not possible with existing zkVMs, but it is not required.Grigore Rosu, CEO, founder and leading the efforts on Pi², attended and gave a presentation about Pi² at the Alt Layer Rollup Frontier Day, a technical conference focusing on today’s emerging rollup space and with participants including the Ethereum Foundation, Flashbots, EigenLayer, RISC Zero, Polychain, Arbitrum, Polygon, Scroll and many more.Grigore Rosu at Alt Layer Rollup Frontier Dayhttps://medium.com/media/a8ffd49f70fbb56d0ad78b0872f83b0c/hrefSymbolik Debugger at TruxtX and EVM SummitWe are currently working on a Symbolic Solidity Debugger, a pioneering tool that marries the intuitiveness of classical interactive breakpoint-style debugging with the depth of symbolic execution. The debugger offers all conventional functionalities, from setting breakpoints to stepping through code (both at the Solidity and EVM levels), inspecting variables, and navigating call stacks.Raoul Schaffranek, who is behind the development of the debugger, had the pleasure of joining two different events during the week to present the symbolic debugger to a broader audience for the first time.On November 14th, Raoul gave a short presentation at the second edition of TrustX, introducing the basics of the debugger. TrustX is an event organized by Secureum that covers various topics related to the Ethereum security ecosystem.Raoul Schaffranek at TrustXhttps://medium.com/media/bf34d9ee83e44d2975d28e99cf56c9cb/hrefAlso, on November 14th, just after his talk at TrustX, Raoul joined the EVM Summit 0 to present a 1-hour workshop about the debugger, allowing more time to dive deeper into the technical details and how it works. The EVM Summit 0 focuses on the execution environment and engine of Ethereum, also known as the EVM.Raoul Schaffranek at EVM SummitERCx at TrustXERCx is a handcrafted, comprehensive, and complete test suites for the most used ERC standards, including, at the moment, ERC-20 (fungible tokens) and ERC-4626 (tokenized vaults), and with more to come soon.Unlike our other tooling, ERCx is already live and ready to use with free plans at https://ercx.runtimeverification.com/. We developed this tool for various audiences, including developers, investors, and casual users worried about their security in the space.Ylies Falcone, project lead of ERCx, also joined TrustX and made a presentation about ERCx and what he learned by testing ERC-20 tokens at large. If you want to learn more about ERCx, check out our blogs and talks at other events.Ylies Falcone at TrustXhttps://medium.com/media/d2d3f89719e0767d7b643ad2e34e0969/hrefParticipation in other eventsBesides the events we mentioned, our team also attended and participated in other events. Grigore Rosu joined Nethermind Summit on a ZK — ZK-VMS and ZK-security panel discussion. Julian Sutherland from Nethermind moderated a panel with Alp Bassa from Veridise, Misha Komarov from =nil; Foundation and Grigore Rosu from Runtime Verification.Grigore Rosu at Nethermind SummitRaoul Schaffranek also had the opportunity to participate in an improvised panel with other attendees at the Formal Verification hangout to talk about different formal verification methods.Raoul Schaffranek at the Formal Verification hangoutThat’s all for our highlights at Devconnect 2023! We had a blast, and we are looking forward to next year’s edition! If you want to know more about what we are working on or ask our team any questions, join us on Discord.</content>
  </entry>
  <entry>
    <title type="html">Runtime Verification October 2023 Updates</title>
    <published>2023-11-02T16:42:32+00:00</published>
    <updated>2023-11-02T16:42:32+00:00</updated>
    <id>https://runtimeverification.medium.com/runtime-verification-october-2023-updates-436fe0eaf147?source=rss-501a37f020aa------2</id>
    <link rel="alternate" type="text/html" href="https://runtimeverification.medium.com/runtime-verification-october-2023-updates-436fe0eaf147?source=rss-501a37f020aa------2"/>
    <author>
      <name>Runtime Verification</name>
    </author>
    <content type="html">Welcome to another issue of our monthly newsletter on Medium. This time around, we bring our updates for the month of October. As always, the updates that we post here are summarized and simple, but we are more than happy to give more details and answer any questions on our Discord server.EVENTSThis time, we are bringing a lot of updates to our events section. Let’s start first with what our team has been up to this past month:Grigore Rosu presented “Pi²” at xDay in Bucharest. Recording available on YouTube.Virgil Serbanuta presented a Kasmer prototype ( property verification for MultiversX) at xDay.Xiaohong Chen presented at OOPSLA. The presentation explained how combining K and matching logic can reduce the trust base of language-agnostic FV from 120k lines of Haskell to a 200-line proof checker.Palina and Jin held a workshop on K and Kontrol at the International Symposium on Automated Technology for Verification and Analysis (ATVA, 2023) in Singapore, with materials and exercises available in the repository: https://github.com/runtimeverification/k-tutorial-atva-2023.Our team in the Bucharest office organized a one-day workshop to discuss different topics, including the state of K, Kontrol, Kasmer, Matching Logic in Lean and Proof of Proof with Pi. All videos are available on YouTube.Daniel presented a talk about FM, Rust, and KMIR at the Rust Brisbane meetup.And to continue, we want to announce that our team will be at DevConnect in Istambul later this month. The team will speak at different events organized by the community about different topics. Here is where you can find them:Grigore Rosu will speak at AltLayer Rollup Frontier Day about “Pi²”Raoul Schaffranek will speak at EVM Summit about “The Symbolic Solidity Debugger”Gigore Rosu will participate in a panel discussion at the Nethermind SummitYliès Falcone will speak at TrustX about “What Did I Learn by Testing ERC-20 Tokens at Large?”Raoul Schaffranek will speak at TrustX about “The Symbolic Solidity Debugger”BLOG POSTSIf you want to know more about ERCx or you have never heard of it, we have you covered. This past month, we published three different articles diving into different areas of our new tool:“Towards a Comprehensive ERC Test Suite” provides an intermediate report to the community on ERCx’s mission of providing the community with handcrafted, comprehensive, and complete test suites for the most used ERC standards.“Is my ERC-4626 vault token up to the standard?” explains how our ERC-4626 test suite works and how you can get started to make sure a contract complies with the standard requirements.“Testing ERC-20 Tokens Part 1: An Arsenal for Bug Detection” is a blog we published in partnership with Certora and compares different test suites and bug-finding tools for ERC-20 tokens.AUDITSDuring October, we published different reports and blog posts from audits completed in the past. For Zivoe we conducted an audit on the Core and Locker contracts and published two different reports and a blog post summarizing the audit. The other audit we announced was the Blockswap’s Stakehouse Withdrawals audit, and we published a technical report with all the details and findings.KONTROL (PREV. K-FOUNDRY)These are the monthly updates from our team working on Kontrol:Updated documentation for Kontrol with up-to-date installation and usage instructions at https://docs.runtimeverification.com/kontrol.Continued the work on factoring out Kontrol — the K- and KEVM-based tool for Foundry projects verification — to a separate tool and repository; for example, the foundry.md file containing semantics of Kontrol and Foundry cheatcodes has been moved to Kontrol, making it easier to support new cheatcodes.Aligned the test selection functionality in `kontrol prove` with that of `forge test`: now, to choose the test(s) to be analyzed, run `kontrol prove — match-test ContractName.methodName` — this command will initiate verification of all functions in ContractName that match the `methodName` regular expression.Enabled infinite gas to be used in `kontrol prove` by default, while fixed amount of gas in a test can be provided via `kevm.setGas(uint256)` cheatcode.`KontrolCheats` contract specifying the interface for Kontrol cheatcodes is now available as an easy-to-use Foundry library: https://github.com/runtimeverification/kontrol-cheatcodes/, which can be installed via `forge install runtimeverification/kontrol-cheatcodes`.Added support for the execution of smart contract initialization code, providing the ability to include test’s constructor into the execution via ` — run-constructor` option in `kontrol prove`.Made simplification of the initial state’s KCFG default in `kontrol prove`.Added `kontrol version` command, which shows the currently installed version of Kontrol.Added the ability to specify the Solidity compiler (`solc`) version to be installed with Kontrol via `kup`: for example, to automatically install `solc` v0.8.13 with Kontrol, run `kup install kontrol.solc_0_8_13`.K FRAMEWORKWe also bring some updates regarding our K efforts:Improvements to K packaging and installation for end users: - Big improvements to kup’s first-touch installation process; the size of a K installation is now much smaller and makes better use of binary caches. - ARM64 Macs are now fully supported for K development. - We have streamlined the set of platforms for which we ship packaged releases, in order to provide better support for our core set of Ubuntu Jammy, macOS and kup.Substantial performance improvements for semantics that rely on C-like (array-of-bytes) memory models via new internal data structures and hooks.ERCxAnd, before wrapping up this month’s newsletter, here are the ERCx updates:We improved our ERC-20 and ERC-4626 test suites by adding more tests, improving some of the tests, and reclassifying some tests.Version 0.8.0 of our VS Code plugin is available. Our plugin lets you run tests individually and per level (minimal, recommended, desirable, …).We added pages listing all top tokens from Etherscan and Uniswap letting you see how those tokens stand with respect to our test suite.We worked hard to crank two test suites for ERC-721 and ERC-1155. These will be made available next month. Stay tuned!That’s all for this month’s updates. Stay tuned and join us in Discord to not miss any news from us.</content>
  </entry>
  <entry>
    <title type="html">Towards a Comprehensive ERC Test Suite</title>
    <published>2023-10-30T21:18:15+00:00</published>
    <updated>2023-10-30T21:18:15+00:00</updated>
    <id>https://runtimeverification.medium.com/towards-a-comprehensive-erc-test-suite-c8aacc82268c?source=rss-501a37f020aa------2</id>
    <link rel="alternate" type="text/html" href="https://runtimeverification.medium.com/towards-a-comprehensive-erc-test-suite-c8aacc82268c?source=rss-501a37f020aa------2"/>
    <author>
      <name>Runtime Verification</name>
    </author>
    <content type="html">Developing ERC tokens can be particularly challenging because of their inherent immutability, the intricacy of their behavior, and the adversarial nature of the environment. Hence, ensuring bug-freedom and mission realization is a difficult and long process. Common practices include manual code review (which is time-consuming and costly) and unit testing (which cover very few behavior of the token contract). One of the most versatile techniques to get almost-immediate feedback on some contract code is property testing. However, writing a comprehensive test suite that catches all possible bugs (aka a complete test suite) requires a considerable effort, and the process is as hard and error-prone as writing the token contract itself.At Runtime Verification, we wanted to address this problem and embarked on a mission to provide the community with handcrafted, comprehensive, and complete test suites for the most used ERC standards. Starting on the same journey most developers from web2 to web3 are likely to follow (the Open Zeppelin ERC templates), we committed to writing hundreds of tests to cover the most common standards: ERC-20, ERC-721, ERC-777, ERC-1155, and ERC-4626.Ensuring quality. We spent hours reading the EIP (Ethereum Improvement Proposal) standard description to cover each function with the required tests. Not only we reviewed and proofread our test suites, we also tested them (yes, we test our test suites) to ensure that they can indeed find all possible bugs a programmer could introduce. One of the methods we used was mutation testing, where specific components of the source code are modified to ensure that the test suite can detect the changes. This ensures consistency and covers for the cases that a human being would miss.Ensuring accessibility. Beyond technical accuracy and quality, we wanted to ensure that our test suites are usable by as many users as possible, from token investors (with possibly no Solidity background) to experienced Solidity developers or auditors. Hence, our test suites are available through several interfaces:a website where one can input some address or Solidity code and get a detailed and thorough evaluation results in a minute.a VSCode plugin enabling using our test suite as in unit testing triggering tests with the click of a button.an open Application Programming Interface allowing the developers to interact with our test suite from any programming language and to do batch evaluations of tokens.This blog post acts as an intermediate report to the community, showing where we are and announcing where we go. So far, we have released two test suites for some of the most arguably common standards: ERC-20 (fungible tokens) and ERC-4626 (tokenized vaults). In the following, we show tables comparing ERCx offering vs available tools and tool suites on the market.Both tables use the following dimensions in the comparison, categorized as follows. First the tables report on the fuzzing capability: only tools relying on the Forge framework allows fuzzing. This is one of the most import criteria since it determines how “deep” the contract under test is evaluated.Then, the tables report on the forms of supported contracts:The third category focuses on the interfaces:Console: ability to use a terminal for running the test suite.Website: ability to use a website UI for running the test suite.API: availability of an API for interacting with the test suite.VSC plugin: availability of a plugin to run the tool in VSCode.The next category is User-friendliness, essentially reflecting how technical aspects of the underlying tool are hidden to the user.No installation required; it indicates whether the user has to use some (command-line) installation before using the tool or is it available out of the box.Usability is an evaluation of the ease of use; while this is a subjective metric, we measure this based on the time spent setting up and running the test suite.Feedback on results indicates whether the tool provides any form of feedback, that can serve as a hint to the user to fix the reported problems.Test runtime as the name suggests is important in that it indicates how long the user has to wait to receive results.The last category, Coverage, indicates how “deep” the tool investigates for finding bugs.Number of tests, as the name suggests, indicates the number of test cases in the test suite. We note that the precise number do not matter since two tests can exercise different behavior but the order of the number still gives a sense of the precision of thoroughness of the test suite.Fuzzing per test indicates how complete is the execution of one test in, for instance, the number of input values it will provide to the tested contract or the number of initial configurations for the tested contract it will consider.Functions from standards indicates how much of the functions described in the corresponding EIP standard are exercised by the test suite.The first table focuses on ERC-20, which is the most common standard, with several offers available: from OpenZeppelin, Slither.The second table focuses on ERC-4626, and we compare it with the test suite from a16z crypto.Stay tuned as we are preparing the release of two new test suites soon!Originally published at https://runtimeverification.com.</content>
  </entry>
  <entry>
    <title type="html">Testing ERC-20 Tokens Part 1: An Arsenal for Bug Detection Towards a Benchmark for ERC-20 Test…</title>
    <published>2023-10-18T21:15:02+00:00</published>
    <updated>2023-10-18T21:15:02+00:00</updated>
    <id>https://runtimeverification.medium.com/testing-erc-20-tokens-part-1-an-arsenal-for-bug-detection-towards-a-benchmark-for-erc-20-test-dd7fb9bcf894?source=rss-501a37f020aa------2</id>
    <link rel="alternate" type="text/html" href="https://runtimeverification.medium.com/testing-erc-20-tokens-part-1-an-arsenal-for-bug-detection-towards-a-benchmark-for-erc-20-test-dd7fb9bcf894?source=rss-501a37f020aa------2"/>
    <author>
      <name>Runtime Verification</name>
    </author>
    <content type="html">Testing ERC-20 Tokens Part 1: An Arsenal for Bug Detection Towards a Benchmark for ERC-20 Test SuitesAbstractRuntime Verification and Certora partnered to analyze a set of tools for detecting bugs in ERC-20 token contracts. In this series of two blog posts, we dive into the tools for detecting bugs in ERC-20 smart contracts. In the first part, we introduce the existing tools and compare them using high-level usability criteria. In the second part, we get more technical and focus on the bug-detection capabilities of these tools, introducing the notion of bug-detection rate. In publishing the second part of this blog post, we will offer an extensible benchmark to the community to evaluate and compare tools.IntroductionThe ERC-20 standard is a set of rules and guidelines for creating smart contracts that govern the behavior of tokens on the Ethereum blockchain. Introduced in 2015, it has become the most widely adopted standard for creating and managing digital assets on the Ethereum platform. ERC-20 tokens are self-executing contracts that represent fungible assets, such as cryptocurrencies or utility tokens. The standard defines a specific set of functions and events that a token contract must implement to ensure compatibility and interoperability with other tokens and decentralized exchanges.While the ERC-20 standard has contributed to the growth of the Ethereum ecosystem, it has also presented security challenges. The decentralized nature of Ethereum and the complexity of smart contracts make them attractive targets for hackers and malicious actors. Vulnerabilities like reentrancy attacks and integer overflow have resulted in significant financial losses in the past. Testing plays a crucial role when it comes to mitigating these risks. By thoroughly testing smart contracts, developers can identify and fix potential bugs and vulnerabilities, safeguarding the security and reliability of their tokens.The Ethereum community has come up with testing frameworks like Forge, Hardhat, and Truffle. Using these tools, developers can write tests, either in Javascript or in Solidity, to test smart contracts. However, a major challenge is to determine whether the current test suite is good enough. This poses the issue of measuring the quality of a test suite, and there is currently no reliable method or tool to do so in the DeFi community. Moreover, while the community has come up with several test suites, such as the ones from Slither and OpenZeppelin, developers are again left alone in evaluating the quality of such test suites.In the rest of this blog post, we will undertake a comparison of some of the most known and publicly available tools used for testing/evaluating ERC-20 tokens. As testing plays a critical role in ensuring the security and reliability of smart contracts, it becomes imperative for developers, especially beginners, to have a good understanding of the available testing tools and their features. By exploring and comparing these tools, we aim to provide valuable insights into their functionalities, ease of use, and effectiveness in detecting potential bugs and vulnerabilities in ERC-20 tokens. Whether you are a developer looking to enhance the quality of your smart contracts or an enthusiast interested in the technical aspects of blockchain, this comparison will equip you with the knowledge needed to make informed decisions while testing ERC-20 tokens. Let us dive into the world of ERC-20 testing tools and uncover their strengths and weaknesses to empower you on your journey to building secure and efficient smart contracts.Existing Tools and their Test Suites for ERC-20We introduce some background about testing and then present the existing test suites for testing ERC-20 tokens.Background: Parametric/Fuzz vs. Unit TestingA test exercises the behavior of a contract by providing it with inputs and observing its outputs. As such, a test examines how the contract responds to various scenarios and checks if it meets certain predefined criteria or requirements (for instance, that some of the values of variables respect some constraint).A parametric test is a test with one (or several) parameter(s); typically, it means the test has parameters/variables (e.g., some amount, or address), and the exact behavior of the test is obtained by providing values to these parameters. Parametric tests are often used to validate the overall performance, reliability, and robustness of a system.While a non-parametric test will exercise only a unique fixed behavior defined in it, a parametric test, in theory, exercises as many behaviors as values that can be taken by its variables.Fuzzing or fuzz testing refers to techniques used for selecting or generating random values for the parameters of parametric tests. An example strategy for obtaining values for parameters consists in using a combination of random values with values obtained from the constants identified in the contract source or bytecode.A unit test is a more specific type of test that checks individual components or units of a program in isolation. It aims to ensure that each unit of code, such as a function or a method, behaves correctly and produces the expected output when given a specific input. Unit tests are different from system tests, which exercise several units or features of the contract.Finally, we note that oftentimes, terminology is not strict, and a unit test may refer to a non-parametric test. We will follow this choice in the rest of this blog post.Tools and Test SuitesWe compare four different tools and their test suites. Each test suite employs a specific setup and approach to assess compliance and/or robustness. In the next section, we evaluate their effectiveness in testing ERC-20 contracts.ERCxERCx provides a test suite of 116 parametric tests. ERCx relies on the Forge testing framework for test execution. Tests in ERCx are structured into six testing levels corresponding to different levels of demand on the contract. ERCx can test ERC-20 contracts described by their address or source code, allowing for evaluation and verification at different stages in the lifecycle of a contract.OpenZeppelinThe OpenZeppelin test suite comprises 158 unit tests. The test suite is specifically designed to test ERC-20 contracts developed by OpenZeppelin as it is tailored to using some of the internal functions of the OpenZeppelin ERC-20 contract. The test suite is publicly available on the OpenZeppelin repository and uses the Hardhat testing framework.SlitherThe Slither test suite comprises 23 detectors. Slither’s analysis aims to identify potential vulnerabilities and security issues in the implementations of ERC-20 contracts. More specifically, Slither performs syntactic checks on functions, their signatures, etc. See this page for more details. While Slither uses static analysis as opposed to tests, it is an effective tool for finding bugs and vulnerabilities in smart contracts due to its security-oriented static analyses.ChatGPTTo explore alternative approaches for test suite design and implementation, we generated a test suite using ChatGPT. The suite comprises 22 unit tests generated through the Hardhat testing framework using the ChatGPT 3.5 language model. While we do not claim that the generated test suite exhausted the possibilities of the tool, the generated test suite constitutes a point of reference about what can automatically be created with a moderate effort of interacting for a few hours with the prompt until no further tests could be generated.Comparing Test SuitesWe now report on the results of comparing the test suites. See the table below.Evaluation CriteriaWe used the following criteria for our comparison:Fuzzing capability: only parametric tests allow fuzzing.From source code: ability to run the test suite on the source code of a contract.From address: ability to run the test suite by only providing the address of an already deployed contract.Console: ability to use a terminal for running the test suite.Website: ability to use a website UI for running the test suite.API: availability of an API for interacting with the test suite.VSC plugin: availability of a plugin to run the tool in VSCode.Usability: evaluation of the ease of use; while this is a subjective metric, we measure this based on the time spent setting up and running the test suite.ResultsThe table above summarizes our findings. Each column represents a test suite indicated by their corresponding tool logos. The comparison criteria, as presented in the previous section, are shown in the rows.Some Notes on ToolsIt is important to note that the OpenZeppelin test suite we evaluated was specifically created to test ERC-20 contracts developed by OpenZeppelin. As such, its primary focus is on ensuring the correctness and reliability of OpenZeppelin’s ERC-20 implementation. While this test suite provided a comprehensive set of unit tests, its usability may be limited when testing other ERC-20 contracts not developed by OpenZeppelin. Developers using this test suite for their own ERC-20 contracts may encounter challenges in adapting and customizing the tests to their specific contract implementations.The Slither tool, specifically the slither-check-erc command used for testing ERC-20 contracts, focuses primarily on checking only the contract&amp;#39;s ABI (Application Binary Interface). However, since Slither performs efficient static analysis, it is capable of detecting many vulnerabilities. Nonetheless, it also suffers from the limitations of any static analysis tool in that it may produce false positives (i.e., it may report non-existent bugs) and is not capable of checking advanced behavioral properties.Final Thoughts: Bringing Advanced Testing to EveryoneIn the context of ERC-20 testing, our aim was to present a thorough behavioral analysis of various test suites to users of Web3 with different profiles and objectives in mind. The ERCx website makes testing and obtaining a report about a token, a one-click operation. Our API facilitates integration with different service platforms. Our VS code plugin brings our tests to developers in a manner that is familiar to them.Coming up Next: Bug-Detection Capabilities and Community BenchmarkIn the following blog, we will dive into the bug-detection capabilities of the tools introduced in this blog post. In particular, we partnered with Certora to demonstrate how we used the Gambit tool developed by Certora to define a bug-detection score, allowing us to objectively compare the tools from a bug-detection perspective and provide a reference benchmark for the community.</content>
  </entry>
  <entry>
    <title type="html">Is my ERC-4626 vault token up to the standard?</title>
    <published>2023-10-17T20:03:49+00:00</published>
    <updated>2023-10-17T20:03:49+00:00</updated>
    <id>https://runtimeverification.medium.com/is-my-erc-4626-vault-token-up-to-the-standard-d8fe2d6c422a?source=rss-501a37f020aa------2</id>
    <link rel="alternate" type="text/html" href="https://runtimeverification.medium.com/is-my-erc-4626-vault-token-up-to-the-standard-d8fe2d6c422a?source=rss-501a37f020aa------2"/>
    <author>
      <name>Runtime Verification</name>
    </author>
    <content type="html">ERC-4626 is an extension of ERC-20 that introduces a standardized interface for tokenized vaults. Any ERC-4626 token also functions as an ERC-20 token, enabling the use of ERC-20 functions like transfer and approve. The primary purpose of ERC-4626 is to act as a vault, enabling users to deposit underlying assets (such as an ERC-20 token named A) in exchange for the vault&amp;#39;s shares (also represented by an ERC-20 token, named S). Depositing assets into the vault allows users to yield interest, thereby offering the potential to withdraw a greater amount of token A than initially deposited, at a later time. To make a vault yield-bearing, it&amp;#39;s essential for the quantity of token A within the vault to increase more rapidly than the production of token S. This objective can be accomplished by identifying optimal yield strategies through various approaches involving lending markets, aggregators, and other interest-bearing tokens.Before the establishment of the ERC-4626 standard, there was no standardization for tokenized vaults. This absence hindered the integration and composability between various yield-bearing token protocols, resulting in complexity and time-consuming processes. Additionally, there was an elevated risk of vulnerabilities due to potential smart contract errors. With the introduction of the ERC-4626 standard by Joey Santoro and his team, developers of tokenized vaults now have a universal guideline to adhere to. This facilitates smoother and more secure integration across different protocols.However, how confident can we be in the behavior of the contracts? Do they follow the standards as required? With the permissionless nature of blockchains, anyone can write and deploy smart contracts in blockchain ecosystems. Thus, it is important to check that they conform to the standard requirements as stated in their respective ERC standard. Without proper checks on deposit and/or withdraw assets functions, interacting with other contract protocols could lead to incompatibility and security issues. There are several ways to check if an ERC-4626 contract complies with its required standard. In this blog post, we will take a look at two different test suites, a16zcrypto’s ERC-4626 test suite and ERCx¹ test suite. We will first briefly explain what we need to know about the ERC-4626 standard before discussing how to use both test suites to check for conformance of an ERC-4626 contract.The ERC-4626 standard in a nutshellAs mentioned previously, an ERC-4626 contract is an extension of an ERC-20 contract. That is, an ERC-4626 tokenized vault must also implement all functions and events required as per ERC-20 standard. One exception is that an ERC-4626 tokenized vault can be non-transferrable, i.e., it may revert on calls to transfer or transferFrom. There are 2 main tokens managed by an ERC-4626 vault - asset (A) and share (S). The asset is the underlying ERC-20 token managed by the vault, which can be used to bear yield. The share is the ERC-20 token of the vault itself, which is used in exchange using any of the four main functions of ERC-4626 standard - deposit, mint, withdraw and redeem. Table 1 and Figure 1 summarize the effects of these functions.Table 1: Effects of calling deposit, mint, withdraw and redeemAdditionally, there are other important functions such as asset, totalAssets, convertTo {Assets, Shares}, preview {Deposit, Mint, Withdraw, Redeem} and max {Deposit, Mint, Withdraw, Redeem} , that allow querying for information about the vault, e.g., exchange ratio between A and S. Details of these functions and other requirements can be found on the ERC-4626 standard website.Checking my ERC-4626 vault tokenEvery function mentioned in the previous section has strict requirements on its inputs, outputs and specification. As mentioned in the introduction, not conforming to the necessary requirements could lead to incompatibility and security issues for the vault token itself and any account or contract interacting with it. For example, having the wrong output type for deposit (uint256,address) to be uint8 instead of the required uint256 could lead to type issues when another contract is interacting with the vault token. Furthermore, if the token does not conform to the rounding requirements as stated in specified in the standard, any account could gain instant monetary gain due to rounding errors. For instance, if an account realizes that there is a loophole such that the amount of shares minted from depositing x amount of assets is greater than the amount of shares burnt from withdrawing the same x amount of assets, he/she could earn “free” shares in the vault token by repeatedly depositing and withdrawing the same amount of assets. Thus, it is important for any ERC-4626 vault token to conform to the required standard. But how can we check our vault tokens if they are up to requirement?There are 2 test suites for ERC-4626 vault token: a16zcrypto’s ERC-4626 test suite and ERCx. Next, we briefly describe how to run each of the test suites and the properties they test before comparing them.a16zcryptoFirst, we note that a16zcrypto’s test suite can be run on both deployed and non-deployed contracts. For non-deployed contracts, using their source code, setting up the test suite is illustrated in Figure 2. The instructions, which can be found in the README file of the test suite repository, are as follows:As the test suite runs forge test from Foundry, install Foundry and forge-std (a necessary dependency).In the vault repository, create a test contract, say ERC-4626ConformanceTest.t.sol, in the test/ directory (create it if need be) and place the custom vault setup method². An example is provided below (Figure 2):3. Run forge test in console.The generated output will state the passing and failing tests accordingly, with counter-examples for failing tests as seen in an example from running the test suite on Openzeppelin’s ERC4626Mock contract (Figure 3). To fully understand the output, please refer to the Foundry book.To make the testing consistent between the two test suites, we ran both test suites on Openzeppelin’s ERC4626Mock contract. It took around 15 to 20 minutes to complete all the tests from a16zcrypto’s test suite. The reason for such a long run is that each test function is set up with a brand new vault with different sets of dummy users, balances and yields before testing the property the function is supposed to test. This means the vaults for the tests are independent of each other. As a result, the test suite provides better fuzzing coverage for each test and has a higher chance to catch edge cases if they exist.The tested properties from the test suite includes:Round-trip properties: no one can make a free profit by depositing and immediately withdrawing back and forth.Functional correctness: the deposit, mint, withdraw, and redeem functions update the balance and allowance properly.The preview{Deposit,Redeem} functions MUST NOT over-estimate the exact amount.The preview{Mint,Withdraw} functions MUST NOT under-estimate the exact amount.The convertTo{Shares,Assets} functions “MUST NOT show any variations depending on the caller.”The asset, totalAssets, and max{Deposit, Mint, Withdraw, Redeem} functions “MUST NOT revert.”ERCxSimilar to a16zcrypto’s test suite, ERCx provides testing for both deployed and non-deployed contracts. However, an additional benefit of using ERCx is that it does not require any prior installation as everything can be run on the website directly. ERCx also provides an Open API for developers to have direct access to the test suite and services. For developers using VS Code for creating their ERC contracts, there is a Visual Studio Code (VS Code) plugin available that allows running the test suite with a click of a button. The instructions to run the test suite on the website are as follows:1.(For deployed contracts) Copy and paste the address of the token you want to test in the text box which can be found on the left column of the Home page of ERCx website as seen in Figure 4. Next, choose the ERC standard test suite you want to test with (for this case, we will be running the ERC-4626 test suite) and the network (Mainnet, Sepolia or Goerlia) the address resides in. Finally, click the “TEST” button.2.(For non-deployed contracts) Copy and paste your source code contract in the text box which can be found on the right column of the Home page of ERCx website as seen in Figure 5³. Next, choose the ERC standard test suite you want to test with and the main contract class before clicking the “TEST” button.The summary of the test results (Figure 6) after running the ERCx test suite on Openzeppelin’s ERC4626Mock contract are structured into levels, where the descriptions of levels are as follows (Table 2):Table 2: Description of tests in each levelThe summary above provides the user a quick snapshot of how the contract has fared against the test suite in terms of conformance and desirable security properties. Any red failing test would immediately be noticeable to the user for future inspection. Figure 7 provides shows how the detailed test results look like:The report page presents a much more readable format of the results, which tells us the description of properties the contract passes or fails. The results can also be filtered via keywords through the “Filter the test results” text box as seen in Figure 7. The page also provides “Detailed Report” and “Test Logs” that may be beneficial to developers who are looking for a summarized report (similar to the report shown in Figure 3).Running the test suite on Openzeppelin’s ERC4626Mock contract took less than 5 minutes. ERCx prioritizes test run speed and better coverage of tested properties over better fuzzing coverage. The main difference between both test suites is that the ERCx test suite fixes a single vault for all its tests instead of having different vaults for different tests like what a16zcrypto’s test suite does. The main reason is to have minimal modifications to the initial states so that it facilitates testing for both deployed and non-deployed contracts. The goal is to keep the current states in the EVM as they are, especially for deployed contracts, for testing, which is done so through a forked environment provided by Foundry. To provide different variations of scenarios, each test from the ERCx test suite will fuzz different shares’ and/or assets’ balance/s only if the test requires it. Although it limits the fuzz inputs for each test, it provides sufficient fuzz coverage for what each test is supposed to test. As a result, this greatly reduces the time taken to run the test suite.The ERCx test suite provides an evaluation of a more comprehensive set of properties⁴. Beyond the properties tested by a16zcrypto’s test suite (i.e., round trip, functional correctness properties, etc) which ERCx also tests, there are many properties stated in the required ERC-4626 standard that are exclusively tested in the ERCx test suite. For example, regarding the maxDeposit(address) function, a16zcrypto’s test suite only checks to make sure that the function MUST not revert (via test_maxDeposit), whereas ERCx checks for that (via testMaxDepositNotRevert) and the following additional properties (Table 3):Table 3: Exclusive tests for maxDeposit(address) in ERCxMoreover, the ERCx test suite provides fingerprint tests that allows identifying the exact issues behind certain failed tests. For example, both a16zcrypto’s and ERCx’s test suite checks if the shares’ balance of receiver indeed increases by the amount of shares output by a successful deposit(assets, receiver) call via the test functions test_deposit and testDepositIncreaseReceiverSharesAsExpected respectively. Other than this test, ERCx also provides the following two tests (Table 4) so that developers can identify the exact issue in the case where the testDepositIncreaseReceiverSharesAsExpected fails:Table 4: Corresponding Fingerprint tests for testDepositIncreaseReceiverSharesAsExpectedComparisonThe following table (Table 5) summarizes the comparison between the two ERC-4626 test suites, a16zcrypto’s and ERCx:There are also certain properties stated in the ERC-4626 standard that cannot be tested through the use of Foundry. These properties will require a trained auditor/verification engineer in the blockchain ecosystem to check for correctness⁵. For example, it is stated in the standard that the maxDeposit(address) “MUST factor in both global and user-specific limits, like if deposits are entirely disabled (even temporarily) it MUST return 0.” However, it is impossible to write a test function (at least in Foundry) to check for global limits or if deposits are entirely disabled.Concluding WordsTo conclude, if you want to test a deployed ERC-4626 contract (either on any of the testnet or on the mainnet itself), it is straightforward to test it with ERC xas all you need is an address. Testing it with a16zcrypto’s test suite seems possible even though when we run it on deployed contracts the execution was not finished after one hour. For testing of non-deployed ERC-4626 contracts, running a16zcrypto’s and ERCx’s test suites is highly recommended. On one hand, the former provides better fuzzing coverage for each property test, and, hence, has a higher chance to catch edge cases if they exist. On the other hand, the latter provides better coverage of properties required from the ERC-4626 standard and can be run in a much shorter time. It is also important to note that both test suites run properties tests through fuzzing. Hence, the results may contain false negatives, i.e., some tests that are supposed to fail may pass because the fuzzing test cannot find counterexamples within the limited number of runs. To guarantee that a contract holds certain properties, one must use formal verification tools such as Kontrol.Getting Further and ContributingLike our ERC-4626 test suite? Want more features for our ERCx tool? Let us know! We are actively looking for feedback on the tool. So if you have any suggestions or features that would improve how you integrate ERCx into your workflow, please contact us. You can also find us at Twitter, Discord and Telegram for more information and updates.Footnotes[1] You can also check out our previous blog post, titled “Introducing ERCx: Conformance and Property-checking for ERC Tokens”, where we first introduced ERCx.[2] Note that the test suite allows some customizations such as _delta, which is the maximum approximation error. Please refer to the test suite repository to find out more.[3] Note that there are some minor requirements such as the contract has to be flatten (i.e., no imports required) and the constructor of the main contract class does not require any input argument, which can be found in the Developers page.[4] Please refer to this page to see the full list of properties tests from the ERCx’s ERC-4626 test suite.[5] If you need a trained auditor/verification engineer to check and verify your contract, you can contact us on our website. You can also find us at Twitter, Discord and Telegram.</content>
  </entry>
</feed>
