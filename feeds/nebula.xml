<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
  <title type="text">Eiger - Blog</title>
  <link rel="alternate" type="text/html" href="https://www.eiger.co/blog"/>
  <link rel="self" type="application/atom+xml" href="http://10.0.0.124:3044/?action=display&amp;bridge=CSSLostDateBridge&amp;home_page=https%3A%2F%2Fwww.eiger.co%2Fblog&amp;url_selector=.w-dyn-item+a&amp;url_pattern=blog%2F.*&amp;content_selector=body+div.rich-text.w-richtext&amp;content_cleanup=&amp;title_cleanup=&amp;date_selector=.cc-blog-date&amp;date_format=F+j%2C+Y&amp;date_selector_index=&amp;author_selector=&amp;remove_styling=on&amp;remove_markup=on&amp;limit=3&amp;format=Atom"/>
  <icon>https://github.com/RSS-Bridge/rss-bridge/favicon.ico</icon>
  <logo>https://github.com/RSS-Bridge/rss-bridge/favicon.ico</logo>
  <id>http://10.0.0.124:3044/?action=display&amp;bridge=CSSLostDateBridge&amp;home_page=https%3A%2F%2Fwww.eiger.co%2Fblog&amp;url_selector=.w-dyn-item+a&amp;url_pattern=blog%2F.*&amp;content_selector=body+div.rich-text.w-richtext&amp;content_cleanup=&amp;title_cleanup=&amp;date_selector=.cc-blog-date&amp;date_format=F+j%2C+Y&amp;date_selector_index=&amp;author_selector=&amp;remove_styling=on&amp;remove_markup=on&amp;limit=3&amp;format=Atom</id>
  <updated>2025-04-11T22:05:55+00:00</updated>
  <author>
    <name>RSS-Bridge</name>
  </author>
  <entry>
    <title type="html">Working on Aptos: Insights into Mutation Testing and Specification Assurance.</title>
    <published>2024-08-02T22:05:55+00:00</published>
    <updated>2024-08-02T22:05:55+00:00</updated>
    <id>https://www.eiger.co/blog/working-on-aptos-insights-into-mutation-testing-and-specification-assurance</id>
    <link rel="alternate" type="text/html" href="https://www.eiger.co/blog/working-on-aptos-insights-into-mutation-testing-and-specification-assurance"/>
    <content type="html">Our exploration of mutation testing with Move offers a glimpse into how we can bolster the robustness of smart contract specifications, increasing overall assurance for developers working on the Aptos blockchain.IntroductionMove Prover, an indispensable tool for Move developers, allows smart contracts written in Move to be formally verified against user specifications. Such formal verification is essential in asserting the correctness and security of contracts, an important tool next to the conventional assurance methods like fuzzing and static analysis.However, the effectiveness of the Move Prover hinges on the quality of the specifications provided. Weak or incomplete specifications can lead to a false sense of security. To address this, we at Eiger developed two key tools, move-mutator and move-spec-test, available in their beta-release, to help developers identify and eliminate potential weak spots in their code&amp;#x27;s specifications.Mutation Testing: A Quick BackgroundMutation testing introduces deliberate errors (mutations) to source code to test the quality of existing tests. It&amp;#x27;s a robust method to identify blind spots that traditional coverage tools might miss. For instance, consider the following Move code snippet:‍public fun inc_and_check(x: &amp;amp;mut u64): bool {    *x = *x + 1;    x &amp;gt; 42 }‍   #[test] fun test_it() {     let x = 3;     inc_and_check(&amp;amp;x);     assert!(x == 4, 0); }‍Despite achieving full code coverage, the test suite for inc_and_check lacks checks for some function behaviors, illustrating the potential blind spots in testing. Mutation testing, by introducing changes such as replacing x &amp;gt; 42 with x &amp;lt; 42, helps verify if the tests can detect these changes. If a mutation passes the existing tests (i.e., the mutant survives), it indicates the tests could be improved.Application to Specification TestingThe move-spec-test tool uses mutation testing principles to evaluate the completeness of Move specifications. We can identify whether the specifications are comprehensive enough by applying the move-mutator to introduce changes in the Move code and running these mutants against the unchanged specifications with the Move Prover.For example, during testing our tool, we analyzed the specifications of the Diem Payment Network. The survival of several mutants highlighted gaps in the specifications, which were confirmed by proof engineers.Consider a simplified Move function:‍fun div(x: u128, y: u128): u128 {     assert!(y != 0, 42);     x / y }‍And its specification:spec div {     aborts_if y == 0 with 42; }‍A mutant where the division operation (/) is replaced with modulo (%) survives the specification verification because the specification does not consider the operation&amp;#x27;s outcome, only its abort condition. This illustrates a blind spot in the specification, which, when improved, can significantly enhance the assurance provided by formal verification.Developed by Eiger, with support from engineers at Aptos Labs, these tools are set to revolutionize how developers approach smart contract security and reliability. Check out the tools on GitHub and share your feedback to help us refine and enhance their capabilities.Who is Aptos?Aptos is a prominent blockchain platform known for prioritizing security, scalability, and usability. It leverages the Move programming language to foster a robust environment for developing decentralized applications. Aptos&amp;#x27; commitment to high-performance blockchain solutions makes it an ideal testbed for advanced tools like the Move Prover, enhancing the reliability of blockchain transactions and smart contract functionality.</content>
    <link rel="enclosure" type="image/png" href="https://cdn.prod.website-files.com/6477417e3abda911e9e87ecc/664edf0f01962d79903136f8_aptos-blog-header.png"/>
  </entry>
  <entry>
    <title type="html">Eiger brings Move to Polkadot</title>
    <published>2024-07-24T22:05:55+00:00</published>
    <updated>2024-07-24T22:05:55+00:00</updated>
    <id>https://www.eiger.co/blog/eiger-brings-move-to-polkadot</id>
    <link rel="alternate" type="text/html" href="https://www.eiger.co/blog/eiger-brings-move-to-polkadot"/>
    <content type="html">We have now completed our work to integrate Move to Substrate. Using this pallet, builders can now integrate the Move VM, thereby allowing Substrate blockchains to execute Move smart contracts. Anyone can now create a Move parachain on Polkadot.OverviewSince our last update in December, we have diligently worked on the Move Substrate integration. Eiger has now finished milestone three and delivered the Move pallet to be used in Substrate. To reach our goals, we had to:adapt the existing Move virtual machine (MoveVM) that can store Move modules and bundles (a collection of modules) and execute Move scripts as smart contracts in Substrate runtime,design a brand-new Substrate pallet in which the MoveVM is integrated and operates in single and multiple signer scenarios,and establish a calibrated and balanced gas cost system for the MoveVM and create a logical connection to Substrate weights so that they can be converted into fees in the blockchain.Project repositorieshttps://github.com/eigerco/pallet-movehttps://github.com/eigerco/substrate-stdlibhttps://github.com/eigerco/substrate-movehttps://github.com/eigerco/move-stdlibMoveVM AdaptationOur work included forking the original Diem-based MoveVM and doing adaptation work to achieve full compatibility within Substrate runtime. The work included the following:Providing a simple MoveVM backend abstract interface with full no-std support encapsulating all MoveVM handling operations, managing storage and balance handling.Direct mapping between 32-byte address space in the MoveVM storage and addresses belonging to Substrate accounts.Setting up a dedicated smove compiler and package tool capable of supporting directly SS58 accounts capable of preparing Move smart contracts for the MoveVM inside the runtime.Pallet Move DesignAs mentioned above, the pallet shall provide the ability to publish Move modules and bundles, and the possibility to call those functionalities when executing Move scripts. Therefore, we defined three important extrinsic calls (pseudo code):‍fn execute(origin, transaction_bc, gas_limit, cheque_limit)fn publish_module(origin, bytecode, gas_limit)fn publish_module_bundle(origin, bundle, gas_limit)‍The signed origins will be turned into the Move datatype signer (authorised Move account access), and the following parameters in different namings will always be the compiled and serialised Move bytecode. The “execute” extrinsic is designed to be used in multiple signer scenarios (situations in which a smart contract needs to be signed by multiple participants). Parachain developers can configure a maximum lifetime and a maximum number of signers for those multiple signer script execution requests via the pallet’s configuration.We will discuss the gas cost background a little more in detail later, but for now, let’s mention that you can limit those costs for executing or publishing Move bytecode.Because the pallet enables Move smart contract developers to transfer tokens directly on the blockchain (internally using the Substrate trait Currency), the user can also specify a ‘cheque limit’ to specify the maximum amount of tokens used during the execution.For parachain maintainers or, more in detail, the sudo user, one more extrinsic is available to update the two Move standard libraries, which technically are bundled but “owned” by sudo:‍fn update_stdlib_bundle(origin, stdlib)‍Gas CostsOperations within the MoveVM can use variable CPU processing time and memory access, and gas fees address that issue. Every Move bytecode instruction and native function call has a fine-tuned defined gas cost. The MoveVM calculates the gas costs for each Move script execution, which are converted to the Substrate weights, which can then be turned into fees in the blockchain. The relation between MoveVM gas and Substrate weight is linear - the more gas the MoveVM consumes, the higher the Substrate fees will be for the end user.By creating parameterised Substrate benchmark functions driven by gas costs and Move example code, we could generate an almost perfectly linear relationship between gas costs and Substrate weights. The Move example code used increased linearly between iterations of the running benchmarks. In case of later gas cost adoptions, only the Substrate-Move internal gas cost table for bytecode instructions needs to be tuned.To avoid unnecessary gas costs, users can estimate the needed amount of gas for publishing a module/bundle and executing a Move script in advance using the tool &amp;quot;smove&amp;quot;, an extended variant of the foregoing &amp;quot;move-cli&amp;quot;.ConclusionThe introduced pallet brings the interoperable Move ecosystem into the Substrate. Slightly tweaked and adapted, but the VM can handle Move language the way it&amp;#x27;s supposed to.We have created comprehensive documentation and two tutorials as part of our commitment to user-friendliness and future updates. These resources provide a quick introduction to using the pallet and guide users on how to modify possible parameter updates in the future. Feel free to reach out to us at hello@eiger.co</content>
    <link rel="enclosure" type="image/png" href="https://cdn.prod.website-files.com/6477417e3abda911e9e87ecc/66a0cc638e908b0a64f8a0a6_polkadot.png"/>
  </entry>
  <entry>
    <title type="html">Releasing Lumina - Directly verify Celestia in your browser</title>
    <published>2024-07-24T22:05:55+00:00</published>
    <updated>2024-07-24T22:05:55+00:00</updated>
    <id>https://www.eiger.co/blog/lumina-release-start-celestia-light-node</id>
    <link rel="alternate" type="text/html" href="https://www.eiger.co/blog/lumina-release-start-celestia-light-node"/>
    <content type="html">Today we are excited to release Lumina. Go to https://lumina.rs/ and you’ll be running a Celestia light node in the browser. By running Lumina you synchronize with the network, sample the network for data availability, directly verify correctness and contribute to the network health.‍Why are light nodes essential to the Celestia networkCelestia is the first blockchain to expand on the idea of lifting light clients&amp;#x27; security. We even call them light nodes, instead of light clients, because in addition to having better security guarantees, they also contribute to the network safety and allow it to scale.Usually, light clients verify only the block headers. They rely on the majority of consensus nodes being honest and the blocks in the chain favored by a consensus being valid. Thanks to the unique approach of Celestia’s Data Availability layer, light nodes can, with high confidence, verify that the block&amp;#x27;s data is available and that the protocol wasn&amp;#x27;t violated with only a single honest full node assumption.The Data Availability layer is a network of nodes which do not actively participate in a consensus but they hold, verify and redistribute the blocks data. The data in the block is divided into shares and laid out in two dimensions as a square. Then it is extended with recovery data, forming a square of double the width (so quadruple the area). Merkle hashes for each row and column of the resulting square are stored in a block&amp;#x27;s header. This two dimensional data structure allows for verifying Merkle proof for just a row or a column which results in much smaller and faster to verify proofs. The attacker would still need to hide more than a half of the data in each row and column, which for the smallest possible Data Square is over 50% of the shares, going down to above 25% as the size grows. Thanks to the recovery (parity) data, if less data than that is hidden, rest can still be recomputed.Light nodes actively sample parts of each block until they reach high confidence that the entire block is available in a process called Data Availability Sampling. They query the network for the randomly chosen set of cells of the block&amp;#x27;s data square (called shares) and check if they find any unavailable. Thanks to the amount of data that needs to be hidden to make the block unavailable, they can reach over 99% confidence that the data can be fully retrieved with just a few samples - for larger blocks they only need to query less than 1% of the data. It is important to note that the sampled data remains in the light nodes memory, so having a lot of light clients sampling blocks gives the network shared security. Parts of blocks&amp;#x27; data are distributed on light nodes and even if the attacker was able to hide the data later on, full nodes can still retrieve it from light nodes. As a consequence of this, the more light nodes in the network, the more data can be stored securely within the block, increasing the Celestia scaling and throughput.But what about the single honest full node assumption? It is possible that the attacker who was selected to build a block hasn’t computed the parity data correctly. Then, the block header would have matching Merkle roots and all the created proofs would still be correct, but we would not be able to recover the missing data with malformed parity data. This cannot be detected by sampling, since proofs are correct, but now the attacker needs to invalidate much less than the assumed 25% of the data to make it unrecoverable. To protect from this kind of attack, when an honest full node receives a full row or a column of the data square, it tries to compute the parity data itself and checks it with the parity data received. If incorrect encoding is detected, fraud proof is announced to all the other nodes. If there is at least a single honest full node which sends such proof, light clients can verify the proof themselves and discard the invalid block.Light nodes are an essential part of the Celestia network and form a backbone of its data availability guarantees. Increasing the number of light nodes contributes to the network&amp;#x27;s overall throughput, security and healthiness as they, in aggregate, can process, verify and secure more data. To help Celestia grow, at Eiger we are working on a light node that’s running in a wasm environment. Wasm is not only performant, but also extremely portable - allowing anyone to run their light node with no more effort than opening an URL. You can run the Lumina node on your device at https://lumina.rs/.‍Synchronize at least 1% and claim a limited NFT.Check out the code at https://github.com/eigerco/lumina ‍Say hello@eiger.co ‍</content>
    <link rel="enclosure" type="image/png" href="https://cdn.prod.website-files.com/6477417e3abda911e9e87ecc/668f9874f23ebf4d8ed312cf_eiger%20lumina.png"/>
  </entry>
</feed>
