<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
  <title type="text">EQ LAB</title>
  <link rel="alternate" type="text/html" href="https://blog.eqlab.io/"/>
  <link rel="self" type="application/atom+xml" href="http://10.0.0.124:3044/?action=display&amp;bridge=CssSelectorFeedExpanderBridge&amp;feed=https%3A%2F%2Fblog.eqlab.io%2Frss%2F&amp;content_selector=article+.gh-content&amp;content_cleanup=&amp;remove_styles=on&amp;limit=3&amp;format=Atom"/>
  <icon>https://github.com/RSS-Bridge/rss-bridge/favicon.ico</icon>
  <logo>https://github.com/RSS-Bridge/rss-bridge/favicon.ico</logo>
  <id>http://10.0.0.124:3044/?action=display&amp;bridge=CssSelectorFeedExpanderBridge&amp;feed=https%3A%2F%2Fblog.eqlab.io%2Frss%2F&amp;content_selector=article+.gh-content&amp;content_cleanup=&amp;remove_styles=on&amp;limit=3&amp;format=Atom</id>
  <updated>2025-04-11T22:09:52+00:00</updated>
  <author>
    <name>RSS-Bridge</name>
  </author>
  <entry>
    <title type="html">Maximizing Performance: Optimization Techniques for Substrate Blockchains</title>
    <published>2023-06-16T16:16:33+00:00</published>
    <updated>2023-06-16T16:16:33+00:00</updated>
    <id>https://blog.eqlab.io/maximizing-performance-optimization-techniques-for-substrate-blockchains/</id>
    <link rel="alternate" type="text/html" href="https://blog.eqlab.io/maximizing-performance-optimization-techniques-for-substrate-blockchains/"/>
    <author>
      <name>EQ Lab</name>
    </author>
    <content type="html">&lt;section class="gh-content gh-canvas"&gt;                 &lt;p&gt;In the decentralized world, optimization is crucial to enhance the efficiency and scalability of various systems. From distributed computing to network protocols, we continually strive to maximize performance and improve user experiences. The blockchain, with its promise of transparent, secure, and decentralized transactions, is no exception. In this article, we'll analyze optimization techniques tailored for Substrate blockchains, shedding light on practical tips to elevate the performance of these innovative platforms.&lt;/p&gt;&lt;p&gt;Before we explore the intricacies of optimization in the blockchain space, let us first establish its significance in the broader context of decentralization.&lt;/p&gt;&lt;h3 id="why-we-optimize-systems"&gt;Why We Optimize Systems&lt;/h3&gt;&lt;p&gt;Optimization empowers us to streamline processes, minimize resource consumption, and increase system efficiency. It enables us to overcome challenges in scalability, latency, and transaction throughput. Through efficient algorithms, leveraging parallel processing, and optimizing data structures, we can realize the true potential of decentralized systems.&lt;/p&gt;&lt;p&gt;Transitioning our focus to Substrate blockchains, we unravel unique characteristics and challenges they present to us. As a modular framework for building blockchain solutions, Substrate provides a rich set of tools and functionalities. However, achieving optimal performance on Substrate blockchains requires a deep understanding of the underlying technology and thoughtful consideration of design choices. At the end of the day, a faster blockchain means a better product and more possible design choices.&lt;/p&gt;&lt;p&gt;Armed with this understanding, we embark on a practical journey, presenting a range of optimization techniques tailored for Substrate blockchains. By optimizing storage and implementing caching strategies, we provide actionable insights to improve the performance and responsiveness of Substrate-based networks.&lt;/p&gt;&lt;h3 id="approaches-to-optimization-in-a-centralized-world"&gt;Approaches to Optimization in a Centralized World&lt;/h3&gt;&lt;p&gt;There are several approaches to optimization in the centralized world. Let's explore these strategies in more detail:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Scaling: Scaling involves expanding the system's capacity to handle a larger transaction volume. There are two main scaling techniques:&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Horizontal Scaling: This approach involves adding extra servers to the network, effectively distributing the transaction load among multiple nodes. We can accommodate a growing number of users and transactions with horizontal scaling.&lt;/li&gt;&lt;li&gt;Vertical Scaling: Vertical scaling focuses on enhancing the capabilities of existing servers by upgrading hardware components such as CPU, memory, or storage, allowing us to improve performance by increasing available computational resources.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;2. Choosing the Best Instruments: Selecting a programming language, databases, and message queues like Rabbit MQ affects the efficiency of applications. Opting for technologies well-suited to the project enables us to improve performance and streamline development.&lt;/p&gt;&lt;p&gt;3. Parallelization and Asynchrony: Leveraging parallel processing and asynchronous programming techniques allows tasks to be executed concurrently in a multithreaded environment, enhancing overall efficiency.&lt;/p&gt;&lt;p&gt;4. Database Optimization: Optimizing the database architecture and configuration is essential for efficient data storage and retrieval. We can reduce latency and enhance query processing speed through techniques such as indexing, sharding, and data compression.&lt;/p&gt;&lt;p&gt;5. Code Optimization: Choosing the most effective algorithms and data structures for implementing various functionalities within the application is crucial for streamlined functionality. Optimized code enhances the efficiency and responsiveness of the system, resulting in improved overall performance.&lt;/p&gt;&lt;p&gt;6. Caching Frequently Used Data and Query Results: We avoid redundant computations and minimize the load by storing frequently used data in a cache.&lt;/p&gt;&lt;p&gt;Incorporating these optimization techniques into the development process enhances performance, scalability, and user experience. Leveraging the power of optimization, we meet market demands by delivering reliable systems capable of scaling up with a growing market.&lt;/p&gt;&lt;p&gt;Having understood the streamlining options in centralized systems, let's explore how we can improve blockchain performance for Substrate-based platforms.&lt;/p&gt;&lt;h3 id="optimizing-substrate-development-for-blockchain-performance"&gt;Optimizing Substrate Development for Blockchain Performance&lt;/h3&gt;&lt;p&gt;When optimizing Substrate development, it's crucial to understand the differentiating factors between Substrate and traditional backend systems. A significant distinction is the access to storage speeds.&lt;/p&gt;&lt;p&gt;In traditional development, memory calls are often made with little consideration for optimization. However, in Substrate, every memory call is expensive. Additionally, Substrate imposes certain limitations on the choice of tools, parallelism, and caching options.&lt;/p&gt;&lt;p&gt;Below is a table explaining the theoretical approaches to optimize blockchain performance within the context of Substrate:&lt;/p&gt;&lt;figure class="kg-card kg-image-card"&gt;&lt;img src="https://blog.eqlab.io/content/images/2023/06/--------------2023-06-16---19.13.12.png" class="kg-image" alt width="941" height="908" sizes="(min-width: 720px) 720px"&gt;&lt;/figure&gt;&lt;p&gt;Although certain limitations exist, we can use caching management and reducing storage calls to achieve notable performance improvement within the Substrate framework.&lt;/p&gt;&lt;p&gt;So, from these theoretical examples, what are the practical steps we can take to optimize Substrate blockchains?&lt;/p&gt;&lt;h3 id="practical-approaches-for-optimizing-substrate-blockchains"&gt;Practical Approaches for Optimizing Substrate Blockchains&lt;/h3&gt;&lt;p&gt;Before proceeding, let's first comprehend how caching works in the Substrate framework:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Quick Access: Accessing cached data is much faster than accessing data from storage.&lt;/li&gt;&lt;li&gt;Cache Population: Data is written to the cache when it's first called from storage.&lt;/li&gt;&lt;li&gt;Least Used Object Removal: The least used object will be removed if the cache becomes full to accommodate new entries.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Let's now examine practical ways to optimize Substrate blockchains.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Utilize Constants: Storing parameters in constants is preferable to pallet storage for customized pallets. Constants aren't kept in storage and therefore don't require resources to read from storage. Although modifying a constant requires updating the chain, the performance improvement is significant enough to outweigh this drawback.&lt;/li&gt;&lt;li&gt;Do not iterate on HashMap: EVM developers who transitioned to Substrate frequently use HashMap to store data. Iterations can be costly, and they don't take advantage of the cache. To address this, we at Equilibrium utilize VecMap - a vector data storage that combines the benefits of a Map interface with high speed.&lt;/li&gt;&lt;li&gt;Storing Pallet Parameters: We prioritize a minimal number of data structures and encourage the creation of large ones. It has a negligible impact on performance while reducing the amount of memory calls notably improves efficiency. In our experience, reading/writing a vector with 1k elements is comparable to a single element. Minimizing the number of read/write operations is essential for optimal performance.&lt;/li&gt;&lt;li&gt;Storing Dynamic Data: Let's look at assets as an example. If our chain doesn't allow users to create new assets, and we often need to access parameters such as price, we can store these parameters in a VecMap instead of a HashMap. This way, the asset will be stored in the cache most of the time, resulting in faster transfers.&lt;/li&gt;&lt;li&gt;Using System Account Data: Before executing an extrinsic, Substrate performs two essential tasks: it checks the nonce and deducts the transaction fee. This action consolidates the System storage into the Account and caches the balances storage. In the cases of Polkadot and Kusama, these two storages are merged, enabling a single read-and-write operation to handle both functions. Expanding the account data provides a suitable place to store frequently used account parameters such as scores, ratings, and nicknames. By leveraging this approach, we can avoid excessive interactions with storage and optimize performance.&lt;/li&gt;&lt;li&gt;Utilize Off-Chain Workers: Off-chain workers, a powerful Substrate feature, contribute to optimization efforts. They allow delegating heavy tasks to be performed off-chain and only verify the result on-chain. At Equilibrium, we apply this approach to manage margin calls. We utilize off-chain workers to monitor accounts and verify margin calls off-chain. We eliminate the need to check all accounts on-chain, enhancing overall performance.&lt;/li&gt;&lt;li&gt;Conduct Extensive Stress Testing: To ensure the optimal performance of our blockchain, we understand the importance of thorough stress testing. While benchmarks provide a preliminary understanding of how complex an extrinsic is, they don't consider critical factors like caching and storage size, which are essential for performance optimization. That's why we subject our system to rigorous stress testing.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;We develop a deeper understanding of the actual duration of transactions and identify potential areas for improvement through the stress tests. They allow us to fine-tune our system, optimizing it for enhanced performance.&lt;/p&gt;&lt;h3 id="additional-blockchain-optimization-ideas"&gt;Additional Blockchain Optimization Ideas&lt;/h3&gt;&lt;p&gt;In addition to the previous optimization techniques, let's mention a couple ideas to further enhance the performance of Substrate blockchains.&lt;/p&gt;&lt;ol&gt;&lt;li&gt;Custom Caching: One way to optimize performance is by implementing custom caching, which involves preloading data when adding an extrinsic (a transaction) to the pool. We can often determine the necessary data and efficiently preload it into the cache by analyzing the extrinsic’s arguments, ensuring faster access.&lt;/li&gt;&lt;li&gt;Deparallelizing data access: Currently, the parallelization implementation in Substrate does not allow storage calls and is thus largely ineffective. For Substrate technology to be competitive with, for example, payments giants, deparallelizing data access is mandatory.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;These practical optimization techniques for Substrate blockchains allow us to improve system performance. We continue to explore and experiment with optimization techniques to realize the full potential of Substrate-based blockchain systems.&lt;/p&gt;             &lt;/section&gt;</content>
    <link rel="enclosure" type="image/png" href="https://blog.eqlab.io/content/images/2023/06/Blog_EQLabs_Improving_Performance_through_Optimization_in_Substrate--1-.png"/>
  </entry>
  <entry>
    <title type="html">How IBC and XCM Drive Interoperability In Polkadot and Beyond</title>
    <published>2023-05-23T16:55:07+00:00</published>
    <updated>2023-05-23T16:55:07+00:00</updated>
    <id>https://blog.eqlab.io/how-ibc-and-xcm-drive-interoperability-in-polkadot-and-beyond/</id>
    <link rel="alternate" type="text/html" href="https://blog.eqlab.io/how-ibc-and-xcm-drive-interoperability-in-polkadot-and-beyond/"/>
    <author>
      <name>EQ Lab</name>
    </author>
    <content type="html">&lt;section class="gh-content gh-canvas"&gt;                 &lt;p&gt;As blockchain technology continues to evolve, achieving seamless communication and interoperability between different chains has become a crucial objective. In this article, we delve into two prominent protocols - Inter-Blockchain Communication (IBC) and Cross-Consensus Messaging (XCM) - that enable secure, permissionless, and trustless transfer of data between blockchains. We will explore both IBC and XCM, their functionality, features, and potential use cases.&lt;/p&gt;&lt;p&gt;At its core, IBC is an interoperability protocol that facilitates the transfer of data, assets, and logic between distinct blockchains. The protocol operates on the principles of simplicity, flexibility, and decentralization, offering a powerful solution for connecting blockchain networks.&lt;/p&gt;&lt;figure class="kg-card kg-image-card"&gt;&lt;img src="https://blog.eqlab.io/content/images/2023/05/data-src-image-34fce0c7-5f25-4f24-be49-51e96f286167.png" class="kg-image" alt width="1600" height="846" sizes="(min-width: 720px) 720px"&gt;&lt;/figure&gt;&lt;p&gt;Three abstraction layers: channels, connections, clients. Channels to identify application, connections for double identity verification, and clients to track consensus state of recipient chains.  &lt;/p&gt;&lt;p&gt;When we send a packet on one chain we will submit a commitment proof, it will be recorded into the state. Then a relayer will construct a packet and add a proof that this was submitted into state and then submit this on the receiving chain which can then verify it using the Light Client of chain A that they have stored on chain B.&lt;/p&gt;&lt;p&gt;There are different Light Clients per consensus type. IBC's scope has expanded beyond the Tendermint consensus chains, thanks to the efforts of projects like Composable, which now support Substrate-based chains.&lt;/p&gt;&lt;p&gt;On top of clients there are connections. They operate once clients have been set up. It is a double identity verification. Both channels and connections are set up by handshakes. &lt;/p&gt;&lt;p&gt;The last layer of abstraction is channels. They are also set up with a handshake. In combination with the port they identify the application. Channel for a fungible token transfer over IBC could look like transfer/channel-0/base-denom where ‘transfer’ is the port name. &lt;/p&gt;&lt;p&gt;Relaying is permissionless and can be incentivized. IBC v4 and onwards contains fee middleware. Two implementations of relayer software available: one is Hermes developed in Rust and another is Go Relayer.&lt;/p&gt;&lt;p&gt;Let’s look at the IBC packet lifecycle using ICS-20 fungible token transfer standard. &lt;/p&gt;&lt;figure class="kg-card kg-image-card"&gt;&lt;img src="https://blog.eqlab.io/content/images/2023/05/data-src-image-ebee2323-5b2f-4676-805d-ad242446727c.png" class="kg-image" alt width="1372" height="750" sizes="(min-width: 720px) 720px"&gt;&lt;/figure&gt;&lt;p&gt;Tokens on the left side are locked up by a user on Chain A, and after the tokens are locked, the packet is sent. The Light Client verification algorithm on Chain B checks whether the tokens on Chain A have been locked and mints IBC vouchers representing tokens of Chain A on Chain B.&lt;/p&gt;&lt;p&gt;Here’s a more generalized packet flow visualization:&lt;/p&gt;&lt;figure class="kg-card kg-image-card"&gt;&lt;img src="https://blog.eqlab.io/content/images/2023/05/data-src-image-c1e542be-f401-42c6-affb-04bc2e744e37.png" class="kg-image" alt width="1555" height="573" sizes="(min-width: 720px) 720px"&gt;&lt;/figure&gt;&lt;p&gt;This packet flow representation can be applied not only to fungible tokens but also to any data packets. Flow can be done in two different ways: by using interchain accounts or via custom applications. &lt;/p&gt;&lt;p&gt;Let’s look at custom IBC applications first.&lt;/p&gt;&lt;figure class="kg-card kg-image-card"&gt;&lt;img src="https://blog.eqlab.io/content/images/2023/05/data-src-image-c97bf563-0095-4555-be82-2bbefeaeb6e9.png" class="kg-image" alt width="1425" height="938" sizes="(min-width: 720px) 720px"&gt;&lt;/figure&gt;&lt;p&gt;Custom IBC applications allow for the development of completely customizable data transfers between chains. The exact requirements for module application to be IBC compatible can be found in the documentation. Specific application logic can then be added to such IBC compatible modules. Any data can be sent to the corresponding counterparty module. ICS-x means that the token will have a number instead of the ‘x’ which refers to a particular application. &lt;/p&gt;&lt;p&gt;Let’s now examine interchain accounts.&lt;/p&gt;&lt;figure class="kg-card kg-image-card"&gt;&lt;img src="https://blog.eqlab.io/content/images/2023/05/data-src-image-5bf4e245-1642-427f-b9b6-3590ad44fb24.png" class="kg-image" alt width="1437" height="915" sizes="(min-width: 720px) 720px"&gt;&lt;/figure&gt;&lt;p&gt;The interchain accounts option allows the use of functionality on Chain B from Chain A without leaving Chain A's environment.&lt;/p&gt;&lt;p&gt;Chains can implement both or either controller or host functionality. Host chain hosts ICA, executes sent txs. Controller chain triggers actions to be executed on the Host chain.&lt;/p&gt;&lt;p&gt;Let’s now explore a scenario where the relayer didn’t pick up the packet.&lt;/p&gt;&lt;figure class="kg-card kg-image-card"&gt;&lt;img src="https://blog.eqlab.io/content/images/2023/05/data-src-image-99d73d1c-be9b-498a-9b53-19c3c0683294.png" class="kg-image" alt width="1569" height="589" sizes="(min-width: 720px) 720px"&gt;&lt;/figure&gt;&lt;p&gt;To avoid funds getting locked up forever a timeout functionality is implemented. The cool thing about IBC is it allows you to query not only receipts but also non-receipts. Such a query allows the user to submit a timeout command and revert the original send packet logic.&lt;/p&gt;&lt;p&gt;ICA have ordered channels. If such a channel has a timeout it is closed automatically. &lt;/p&gt;&lt;p&gt;Functionality that doesn't go in the IBC core can be used as middleware and reused for different applications thus building a middleware stack.&lt;/p&gt;&lt;figure class="kg-card kg-image-card"&gt;&lt;img src="https://blog.eqlab.io/content/images/2023/05/data-src-image-bb098dd6-b950-4347-bcdb-8056623fd1ca.png" class="kg-image" alt width="1523" height="696" sizes="(min-width: 720px) 720px"&gt;&lt;/figure&gt;&lt;p&gt;This diagram shows that we can keep stacking middleware and create functionality that way. Here packet and write_ack go from base application to Core IBC. Handshake, acks and timeouts go from Core IBC through the middleware to the base application. Order matters and must be replicated on the counterparty chain.&lt;/p&gt;&lt;p&gt;XCM is a cross-chain messaging protocol that enables the transfer of data and assets between chains in a more sophisticated and programmable way than ever before. XCM V3 includes improvements in three key areas: expectations and branching, introspection and safe dispatches, and asset exchange and NFTs.&lt;/p&gt;&lt;p&gt;Let’s now examine expectations and branching in more detail.&lt;/p&gt;&lt;figure class="kg-card kg-image-card"&gt;&lt;img src="https://blog.eqlab.io/content/images/2023/05/data-src-image-5a1d78b5-bb85-42bb-b09e-45205de74b78.png" class="kg-image" alt width="1600" height="673" sizes="(min-width: 720px) 720px"&gt;&lt;/figure&gt;&lt;p&gt;There are three new instructions: ExpectAsset, ExpectError and ExpectOrigin. They are related to three existing registers: Holding, Error, Origin. This allows for branching: changing the flow depending on errors thrown.&lt;/p&gt;&lt;figure class="kg-card kg-image-card"&gt;&lt;img src="https://blog.eqlab.io/content/images/2023/05/data-src-image-455dedd6-14dc-47bd-81f5-954cb00f11aa.png" class="kg-image" alt width="1330" height="866" sizes="(min-width: 720px) 720px"&gt;&lt;/figure&gt;&lt;p&gt;Safe dispatches allow for version control of destination chain and specific pallet. There is a new register called ‘Transact Status Register’ and four new instructions: QueryPallet, ExpectPallet, ReportTransactStatus, ClearTransactStatus. The new register holds the result of the most recent transact operation. QueryPallet gives back the instances of a specific pallet or module. ExpectPallet throws an error if the expected version does not match the one we get back. ReportTransactStatus reports what the Transact Status Register holds and ClearTransactStatus clears the data. &lt;/p&gt;&lt;p&gt;The goal of these statuses is to ensure no unexpected behavior is happening. &lt;/p&gt;&lt;p&gt;The second big category introduced in XCM v3 is Functional Multichain Decomposition. It is designed to allow for building utilizing logic from multiple chains. The changes here can be grouped into three categories:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Remote Locking&lt;/li&gt;&lt;li&gt;Context/ID for tracking messages &amp;amp; queries&lt;/li&gt;&lt;li&gt;Asset Namespacing&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Remote Locking enables chains to use assets in other chains. Four new instructions here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;LockAsset&lt;/li&gt;&lt;li&gt;UnlockAsset&lt;/li&gt;&lt;li&gt;NoteUnlockable&lt;/li&gt;&lt;li&gt;RequestUnlock&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;One of the goals for Functional Multichain Decomposition is to enable tracking XCM messages. A new register ‘Topic’ is introduced. It can be set to any value and used as an ID by itself or in combination with ‘Origin’ to create a unique identifier. &lt;/p&gt;&lt;p&gt;There is a way to let ExmExecutor know about the context of the instruction using the XcmContext struct. It has three fields: Origin, XcmHash, Topic. This allows to track XCM message’s context and thus have an application spread between different shards. &lt;/p&gt;&lt;p&gt;The third big area of note is bridging. The four key improvements here are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Universal Location&lt;/li&gt;&lt;li&gt;Message Exporting&lt;/li&gt;&lt;li&gt;Two stage Send and Export&lt;/li&gt;&lt;li&gt;Logical Origins&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Universal Location is a new and unique location, a parent of all locations (different consensus systems). It encompasses relay chains and parachains. It has no parent and allows to use ‘Context’ for locating within the Universal Location. &lt;/p&gt;&lt;p&gt;There are three new SendXcm impls to manage routing over a bridge. They cover three scenarios:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;The bridge is local&lt;/li&gt;&lt;li&gt;The bridge is in Local consensus but not on local chain (no fees expected)&lt;/li&gt;&lt;li&gt;The bridge is not local (fees expected)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Two stage Send and Export means that SendXcm is now a two-stage process: validate and deliver. Validate does price discovery and returns a ticket. Deliver executes the transaction. &lt;/p&gt;&lt;p&gt;The rise of IBC and XCM protocols represents significant milestones in achieving seamless communication and interoperability across blockchain networks. Through their secure, permissionless, and trustless nature, IBC and XCM empower developers to create decentralized applications that transcend the boundaries of individual chains. By enabling data transfer, asset exchange, and sophisticated programmability, these protocols pave the way for the next generation of blockchain innovation, facilitating collaboration, scalability, and enhanced user experiences in the decentralized ecosystem.&lt;/p&gt;             &lt;/section&gt;</content>
    <link rel="enclosure" type="image/png" href="https://blog.eqlab.io/content/images/2023/05/Blog_EQLabs-Exploring--IBC---XCM-protocols.png"/>
  </entry>
  <entry>
    <title type="html">How Binary Heaps Are Utilized In A Leveraged Trading Protocol On EVM</title>
    <published>2023-04-26T16:34:04+00:00</published>
    <updated>2023-04-26T16:34:04+00:00</updated>
    <id>https://blog.eqlab.io/how-binary-heaps-are-utilized-in-a-leveraged-trading-protocol-on-evm/</id>
    <link rel="alternate" type="text/html" href="https://blog.eqlab.io/how-binary-heaps-are-utilized-in-a-leveraged-trading-protocol-on-evm/"/>
    <author>
      <name>EQ Lab</name>
    </author>
    <content type="html">&lt;section class="gh-content gh-canvas"&gt;                 &lt;p&gt;EQ Lab develops a variety of different products on multiple blockchain platforms. Among others, there is am EVM-based decentralized lending protocol that allows users to take up to 20x leveraged long and short positions on crypto assets across different DEX-es and AMMs. In this article we will explore how this product utilizes binary heaps to handle margin calls.&lt;/p&gt;&lt;h3 id="pools"&gt;Pools&lt;/h3&gt;&lt;p&gt;The protocol is comprised of liquidity pools. Each pool consists of a quote asset (stablecoin) and a base asset (risk asset). For each pool there is a corresponding AMM pool where quote and base assets can be exchanged. Lending pools allow to deposit base or quote asset, go long or short (borrow the other asset with up to 20x leverage), withdraw base or quote asset, and close long/short positions.&lt;/p&gt;&lt;p&gt;Four indexes are calculated for each pool. They are baseCollateralCoeff, baseDebtCoeff, quoteCollateralCoeff, quoteDebtCoeff. These are used to determine interest rates.&lt;/p&gt;&lt;h3 id="positions"&gt;Positions&lt;/h3&gt;&lt;p&gt;There are three types of positions: Lend, Long, and  Short  When a user creates any of these positions a discounted balance is stored instead of the “real” balance. This is how it is calculated:&lt;/p&gt;&lt;p&gt;discountedBalance = realBalance / coeff&lt;/p&gt;&lt;p&gt;There are separate coefficients for Lend, Long and Short positions. For example if a Lend position is created by depositing quote asset the following calculation applies:&lt;/p&gt;&lt;p&gt;discountedQuoteAmount = realAmount / quoteCollateralCoeff&lt;/p&gt;&lt;p&gt;The calculation for Short and Long positions is as follows:&lt;/p&gt;&lt;p&gt;discountedBaseAmount = realAmount / quoteDebtCoeff&lt;/p&gt;&lt;p&gt;Short and Long positions are then stored in two separate collections. They are sorted in descending order of debtAmount/collateralAmount. For short positions this is calculated as baseAmount/quoteAmount, and for long positions the calculation is quoteAmount/baseAmount.&lt;/p&gt;&lt;p&gt;These sorted positions are stored in a Max binary heap.&lt;/p&gt;&lt;p&gt;Any user action that changes a position’s quoteAmount/baseAmount ratio triggers a recalculation of the binary heap such that the first element is always the riskiest position. &lt;/p&gt;&lt;h3 id="interest-rates"&gt;Interest rates&lt;/h3&gt;&lt;p&gt;Interest rates are scaled proportionally to asset volatility and leverage. Total long leverage and total short leverage is calculated for each pool. Users who take up long or short positions pay interest fees to collateral providers. Fee accrual is done by changing  baseCollateralCoeff, quoteCollateralCoeff coefficients. Fee write-off occurs by modifying the baseDebtCoeff and quoteDebtCoeff.&lt;/p&gt;&lt;h3 id="margin-calls"&gt;Margin calls&lt;/h3&gt;&lt;p&gt;User action triggers a heap check of long and short positions leverages. Leverage is calculated for the riskiest position (heap root). It is then compared to the max leverage pool parameter. If the position’s leverage exceeds max leverage, the position is liquidated. In this case collateral is swapped and used to cover liabilities. The rest is then distributed between lenders. If there is not enough collateral to settle, the lenders cover the difference. These actions are performed by modifying baseCollateralCoeff or quoteCollateralCoeff. This way individual balances don’t need to be changed. &lt;/p&gt;&lt;p&gt;This design allows to run an automated liquidator as well as potentially implement no-liquidation systems in future versions of the protocol. It is more capital efficient compared to designs that implement collateral, debt and balances positions for each user because liquidity can be reused: the same capital can be used to go both long and short simultaneously. This could ultimately result in a superior product and user experience.&lt;br&gt;&lt;/p&gt;             &lt;/section&gt;</content>
    <link rel="enclosure" type="image/png" href="https://blog.eqlab.io/content/images/2023/04/Blog_EQLabs-Learn-more-about-builder--1170-700---4-.png"/>
  </entry>
</feed>
