<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
  <title type="text">Cubist Blog – Web3 security: key management, hardware, crypto wallets, staking</title>
  <link rel="alternate" type="text/html" href="https://cubist.dev/blog"/>
  <link rel="self" type="application/atom+xml" href="http://10.0.0.124:3044/?action=display&amp;bridge=CSSLostDateBridge&amp;home_page=https%3A%2F%2Fcubist.dev%2Fblog&amp;url_selector=.w-dyn-item+a&amp;url_pattern=%2Fblog%2F.*&amp;content_selector=.article-c&amp;content_cleanup=&amp;title_cleanup=&amp;date_selector=.blog-cms__date+.text-color-darkblue&amp;date_format=F+j%2C+Y&amp;date_selector_index=&amp;author_selector=&amp;remove_styling=on&amp;remove_markup=on&amp;limit=3&amp;_cache_timeout=3600&amp;format=Atom"/>
  <icon>https://github.com/RSS-Bridge/rss-bridge/favicon.ico</icon>
  <logo>https://github.com/RSS-Bridge/rss-bridge/favicon.ico</logo>
  <id>http://10.0.0.124:3044/?action=display&amp;bridge=CSSLostDateBridge&amp;home_page=https%3A%2F%2Fcubist.dev%2Fblog&amp;url_selector=.w-dyn-item+a&amp;url_pattern=%2Fblog%2F.*&amp;content_selector=.article-c&amp;content_cleanup=&amp;title_cleanup=&amp;date_selector=.blog-cms__date+.text-color-darkblue&amp;date_format=F+j%2C+Y&amp;date_selector_index=&amp;author_selector=&amp;remove_styling=on&amp;remove_markup=on&amp;limit=3&amp;_cache_timeout=3600&amp;format=Atom</id>
  <updated>2025-04-11T22:04:56+00:00</updated>
  <author>
    <name>RSS-Bridge</name>
  </author>
  <entry>
    <title type="html">Cubist Blog - Understanding and preventing the Bybit hack</title>
    <published>2025-02-25T22:04:56+00:00</published>
    <updated>2025-02-25T22:04:56+00:00</updated>
    <id>https://cubist.dev/blog/understanding-and-preventing-the-bybit-hack</id>
    <link rel="alternate" type="text/html" href="https://cubist.dev/blog/understanding-and-preventing-the-bybit-hack"/>
    <content type="html">Several days ago, the Lazarus group &amp;lt;a href=&amp;quot;https://www.forbes.com/sites/digital-assets/2025/02/21/latest-on-the-bybit-record-breaking-14-billion-dollar-crypto-hack/&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;hacked the Bybit exchange&amp;lt;/a&amp;gt; for around one and a half billion dollars. The attack was clever—it required deep knowledge of Bybit’s internal operations—and technically sophisticated. &amp;lt;br&amp;gt; It was also _completely preventable_. &amp;lt;br&amp;gt; This blog post first digs into the hack itself, and then explains how a different approach to security would have made the attackers’ job much harder. &amp;lt;br&amp;gt; ## How the hack happened &amp;lt;br&amp;gt; Bybit uses on-chain “&amp;lt;a href=&amp;quot;https://safe.global&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;Safe&amp;lt;/a&amp;gt;” wallets to store (large amounts of) funds, and then periodically, manually transfers funds from those wallets to other wallets. To approve transfers, three Bybit signers navigate to the wallet UI and view the transaction details. If everything looks good, they use a hardware device (e.g., a Ledger) to sign the transaction. When the final signer approves, the UI broadcasts the fully-signed transaction to the blockchain. &amp;lt;br&amp;gt; ### Operations under attack &amp;lt;br&amp;gt; The attacker started by deploying two contracts: &amp;lt;ol&amp;gt; &amp;lt;li&amp;gt;A malicious contract that transfers ETH and ERC20 tokens to any address that the attacker chooses.&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;A contract that upgrades a standard Safe contract to instead point to the malicious contract.&amp;lt;/li&amp;gt; &amp;lt;/ol&amp;gt; &amp;lt;br&amp;gt; The attacker’s goal was to get the Bybit signers to approve a contract upgrade transaction; once the cold wallet contract logic was replaced by malicious logic, the attackers could drain all the wallet’s funds to the address of their choice. Unfortunately (for the attacker), presenting the Bybit signers with the chance to `upgrade` their Safe to a malicious contract would almost certainly fail: the signers would veto the transaction immediately. Thus, the attackers had to _trick_ the signers into approving the upgrade by making it look like something…safe. &amp;lt;br&amp;gt; Their first step was to implement the upgrade in a non-standard—and thus harder to detect—way. Instead of using a standard `upgrade` transaction, they &amp;lt;a href=&amp;quot;https://www.certik.com/resources/blog/3wI26AFKF1UtSDjJEXNEDM-bybit-incident-technical-analysis&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;implemented&amp;lt;/a&amp;gt; &amp;lt;a href=&amp;quot;https://www.blockaid.io/blog/the-15b-bybit-hack-explained-a-technical-breakdown&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;the&amp;lt;/a&amp;gt; &amp;lt;a href=&amp;quot;https://x.com/dhkleung/status/1893073663391604753&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;upgrade&amp;lt;/a&amp;gt; so that its transaction’s data looked like a `transfer`. This alone is probably insufficient: while a `transfer` is plausible, this _particular_ transfer is very strange looking. It’s not even ERC-20 compliant, for example. &amp;lt;br&amp;gt; The attacker’s second step was to make the upgrade look _absolutely, completely routine_. This isn’t possible at the contract level: no matter what, a contract upgrade is going to look different from your ordinary, once-a-week transfer. Luckily (for the attacker), there’s another way. Recall that the Bybit signers navigate to the UI to view transaction details and approve transactions. Thus, to get their evil upgrade approved, the attackers could make the UI display one thing—a completely normal transfer—while collecting a signature on something else—a malicious upgrade. &amp;lt;br&amp;gt; To pull off this attack, the attackers had to get three key Bybit employees to navigate to the evil (but normal-looking) UI. One possibility is that a phishing attack got them to click on a link that sent them directly to the evil UI; another possibility is a &amp;lt;a href=&amp;quot;https://blog.google/threat-analysis-group/0-days-exploited-wild-2022/&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;more sophisticated&amp;lt;/a&amp;gt; phishing attack, one that sent them to a webpage embedding malicious code that compromised their machines (and ultimately displayed the evil UI). &amp;lt;br&amp;gt; Once the Bybit employees had looked at the malicious transaction details in the evil UI and deemed them safe, they needed to actually sign the transaction. This is where the entire attack could have broken down: if the Bybit employees had examined the transaction details _on their hardware devices_—instead of just in the UI—they would have seen the weird-looking transfer. Instead, the attackers knew (or suspected) that Bybit operations used “&amp;lt;a href=&amp;quot;https://x.com/Ledger/status/1893956121385165278&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;blind signing&amp;lt;/a&amp;gt;,” where transaction details aren’t displayed on the hardware wallet. This meant that a compromised UI was enough to trick all three Bybit signers into approving a malicious contract upgrade—which cost them over a billion dollars. &amp;lt;br&amp;gt; ### Feb 26th 2025 update: &amp;lt;br&amp;gt; According to the most &amp;lt;a href=&amp;quot;https://x.com/safe/status/1894768522720350673&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;recent&amp;lt;/a&amp;gt; &amp;lt;a href=&amp;quot;https://www.bybit.com/en/press/post/bybit-confirms-security-integrity-amid-safe-wallet-incident-no-compromise-in-infrastructure-blt9986889e919da8d2&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;reports&amp;lt;/a&amp;gt;, the evil UI wasn’t the result of a phishing attack against Bybit. Instead, the attackers were able to compromise a Safe employee and make malicious modifications to the _real_ UI that’s used by all Safe customers. &amp;lt;br&amp;gt; This is the worst possible case: the attackers had the power to subvert the operation of the UI for _all_ users, not just for Bybit. And in Safe&amp;#x27;s design, the UI is a fully trusted component of the system—so this is unequivocally a compromise of Safe. (It&amp;#x27;s true that the smart contract itself was not compromised. But that hardly matters: as proved by this attack, an attacker does not need to compromise the smart contract in order to drain a Safe.) &amp;lt;br&amp;gt; Stepping back: securing code deployment is one of the fundamental requirements for operating security-critical systems. It is astonishing that compromising one Safe employee was sufficient to subvert a security-critical component of the Safe system. This particular attack vector could have been prevented by following best practices—and while there are more sophisticated attack vectors, this is sadly a reminder that securing software development, deployment, and the supply chain more broadly is as critical to Web3 as it&amp;#x27;s been for Web2. &amp;lt;br&amp;gt; ## How to prevent something similar &amp;lt;br&amp;gt; This attack _should not_ have happened: wallet and key management providers have developed all sorts of strategies that would thwart such a thing. We’ll give an example by walking through several ways that a hardware-backed CubeSigner wallet with a 3-out-of-3 approval requirement would have prevented the hack. &amp;lt;br&amp;gt; ### Don’t blind sign &amp;lt;br&amp;gt; If you—or your wallet/key management platform, as we discuss below—can’t examine the details of the transaction you’re signing, there’s very little you can do to prevent exploits. (CubeSigner does have a few features that _do_ help but we’ll talk about them in a future post.) Just don’t blind sign. &amp;lt;br&amp;gt; ### Use policies (and don’t enforce them on the client machine) &amp;lt;br&amp;gt; Signing policies are rules like “don’t sign any transfer over a certain amount”; if a transaction violates the policy, the system simply refuses to sign it. Crucially, CubeSigner enforces policies in the system backend—_not_ on client machines. As a result, if the UI displays a safe transaction but submits an _unsafe_ one to the backend for signing, that transaction will be rejected. &amp;lt;br&amp;gt; Here’s an example set of policies that would prevent the attack with essentially no inconvenience in day-to-day operations: &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;Require 3/3 YubiKey approvals from the Bybit signers. (YubiKeys give an extra layer of defense against phishing attacks: a YubiKey approval sent to an evil UI would include different metadata than one sent to the real UI, so the approval would fail).&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Only allow transfers to a known set of warm wallet addresses. This prevents any unusual or malicious transfers by construction.&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Only allow transfers of a certain amount in a certain time window. This prevents attackers from draining all the funds in the wallet.&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;br&amp;gt; Even if an attacker phishes the Bybit signers into approving a massive transfer to a malicious address, this set of policies would immediately reject the transfer. &amp;lt;br&amp;gt; That’s not _quite_ what happened, though: in the hack, the attackers got the Bybit signers to approve a contract upgrade by making it look like a transfer. There’s no off-chain equivalent of a smart contract upgrade. The closest thing is a governance change: tricking the Bybit signers into removing all the policies we just set (in order to then trick them into signing evil transfers). Which brings us to… &amp;lt;br&amp;gt; ### Separate governance policies and signing policies &amp;lt;br&amp;gt; Governance policies are rules like “five out of seven people must approve this signing policy change”; instead of controlling what a wallet can sign, they control how and when it’s possible to change the policy on a wallet. &amp;lt;br&amp;gt; We might configure our cold wallet with two policies: &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;Require 5/7 YubiKey approvals to change the wallet’s signing policy. (Remember: YubiKeys enhance security against phishing.)&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Require a 7-day waiting period for changes to the wallet’s signing policy. Even if approvers are tricked into approving malicious changes, they have time to cancel those approvals. This is especially powerful in concert with alerts on governance changes.&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;br&amp;gt; At this point, it’s very hard for the attacker to make a governance change look like a transaction request: governance changes require both more approvers and different approvers than signature requests. Furthermore, since CubeSigner’s transaction approvals and governance approvals are completely different, it’s impossible for an attacker to collect approvals for signatures and then use them to approve governance changes. &amp;lt;br&amp;gt; ### Incorporate transaction monitoring services &amp;lt;br&amp;gt; There are many excellent transaction monitoring and simulation tools that would, for example, have flagged that the upgrade transaction was suspicious. You can use any of these tools in combination with CubeSigner! Look out for an update 👀 on how to integrate your favorite. &amp;lt;br&amp;gt;</content>
    <link rel="enclosure" type="image/png" href="https://cdn.prod.website-files.com/638a2693daaf8500030065a2/67be1c2a03c5a520d47713d4_bybit-hack-key-management-og.png"/>
  </entry>
  <entry>
    <title type="html">Cubist Blog - K3 brings wallet automations to CubeSigner users</title>
    <published>2025-02-05T22:04:56+00:00</published>
    <updated>2025-02-05T22:04:56+00:00</updated>
    <id>https://cubist.dev/blog/k3-brings-wallet-automations-to-cubesigner-users</id>
    <link rel="alternate" type="text/html" href="https://cubist.dev/blog/k3-brings-wallet-automations-to-cubesigner-users"/>
    <content type="html">We are beyond excited to announce that we’ve partnered with &amp;lt;a href=&amp;quot;https://www.k3-labs.com&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;K3 Labs&amp;lt;/a&amp;gt; to provide the secure wallet infrastructure underlying their new drag-and-drop Web3 automation platform. K3’s mission is to radically reduce time to market and cost of operations by helping traders, node operators, and enterprise companies automate their day-to-day Web3 tasks. &amp;lt;br&amp;gt; ## Partnering to make wallet automations easy and secure &amp;lt;br&amp;gt; It is time-consuming and tedious to manually rebalance wallets, execute trading strategies, claim liquidity provider rewards, monitor liquidity pools, report crypto balances, bridge off-chain and on-chain data, and complete other repetitive tasks that are part of daily Web3 operations. Developers often spend days/weeks/months writing custom code to automate these workflows. We’re thrilled that the K3 platform offers an easier, faster alternative: customizable automation templates that read and write between on and off-chain data sources and instantly trigger processes or alerts. &amp;lt;br&amp;gt; &amp;lt;blockquote&amp;gt;&amp;quot;We are happy to be working with Cubist to make Web3 easier to use by automating many of the most common repetitive tasks for both technical and non-technical users. Their focus on security without sacrificing convenience made Cubist a great fit for us.&amp;quot; &amp;lt;footer&amp;gt;- William Herkelrath, Co-Founder &amp;amp; CEO at K3 Labs&amp;lt;/footer&amp;gt; &amp;lt;/blockquote&amp;gt; &amp;lt;br&amp;gt; ## What does this mean for CubeSigner users? &amp;lt;br&amp;gt; K3 is an obvious partner for us because their workflow UI provides a way for less-technical CubeSigner users to automate away manual tasks involving their CubeSigner wallets—without writing code. The K3 interface provides pre-built workflows for read functions, write functions, and operational functions that make use of market and NFT data, smart contract and deployment activity, and wallet balances. &amp;lt;br&amp;gt; It’s easy to use CubeSigner with K3, just drag and drop! &amp;lt;br&amp;gt; &amp;lt;iframe width=&amp;quot;560&amp;quot; height=&amp;quot;315&amp;quot; src=&amp;quot;https://www.youtube.com/embed/GrzmJZwI0ls?si=h0s28wcVoF6ER-gA&amp;quot; title=&amp;quot;YouTube video player&amp;quot; frameborder=&amp;quot;0&amp;quot; allow=&amp;quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&amp;quot; referrerpolicy=&amp;quot;strict-origin-when-cross-origin&amp;quot; allowfullscreen&amp;gt;&amp;lt;/iframe&amp;gt; &amp;lt;br&amp;gt; K3 chose Cubist as their wallet provider because they care about the security of their user’s assets. A critical design point of the integration is that users maintain full ownership and hardware protection of their private keys while delegating permissions to the K3 platform to sign transactions that are part of automations they’ve configured. Users can expect the same millisecond signing and robust security that CubeSigner is known for, combined with ease of use and seamless integration when building workflows through K3. Simply create a new CubeSigner wallet or connect an existing one through the K3 UI. &amp;lt;br&amp;gt; We look forward to this integration bringing efficiency to the teams we serve. &amp;lt;a href=&amp;quot;https://app.k3-labs.com/register&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;Create a K3 account here&amp;lt;/a&amp;gt; and try it for free, or &amp;lt;a href=&amp;quot;/contact-form-cubesigner-hardware-backed-key-management&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;get in touch&amp;lt;/a&amp;gt; to learn more. &amp;lt;br&amp;gt; &amp;lt;pre&amp;gt;&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; &amp;lt;br&amp;gt; &amp;lt;br&amp;gt; &amp;lt;br&amp;gt; &amp;lt;/pre&amp;gt;&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; **About K3 Labs** &amp;lt;br&amp;gt; K3 Labs is a Web3 automation platform aiming to be the blockchain world&amp;#x27;s front end. With features tailored for both hardcore developers and less-technical users, K3 makes deploying and running daily operational automations as easy as dragging, dropping, and configuring workflow steps through an intuitive interface. The K3 platform&amp;#x27;s production release is supported by over 20 node operators and more than $2 billion in restaked assets, providing exceptional decentralized service reliability and robust crypto-economic security. To learn more about K3, visit &amp;lt;a href=&amp;quot;https://www.k3-labs.com&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;https://www.k3-labs.com&amp;lt;/a&amp;gt;.&amp;lt;br&amp;gt;</content>
    <link rel="enclosure" type="image/png" href="https://cdn.prod.website-files.com/638a2693daaf8500030065a2/67a2a5d280a9084d19dc1125_k3-cubesigner-new-wallet-automation-templates-og.png"/>
  </entry>
  <entry>
    <title type="html">Cubist Blog - Cubist teams up with Babylon and Lombard to bring Bitcoin to Sui</title>
    <published>2024-11-25T22:04:56+00:00</published>
    <updated>2024-11-25T22:04:56+00:00</updated>
    <id>https://cubist.dev/blog/cubist-teams-up-with-babylon-and-lombard-to-bring-bitcoin-to-sui</id>
    <link rel="alternate" type="text/html" href="https://cubist.dev/blog/cubist-teams-up-with-babylon-and-lombard-to-bring-bitcoin-to-sui"/>
    <content type="html">This morning the Sui Foundation announced their collaboration with Cubist, &amp;lt;a href=&amp;quot;https://babylonlabs.io/&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;Babylon&amp;lt;/a&amp;gt;, and &amp;lt;a href=&amp;quot;https://www.lombard.finance/&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;Lombard&amp;lt;/a&amp;gt; to make Bitcoin liquidity available in Sui’s DeFi ecosystem.&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; ## LBTC is coming soon to Sui&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; Together with Lombard, we have been extending the CubeSigner hardware-backed key management platform to bring smart contract capabilities to Bitcoin and unlock Bitcoin liquid staking across DeFi.&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; Today, CubeSigner powers (1) &amp;lt;a href=&amp;quot;/blog/new-key-management-workflows-for-babylon-btc-staking&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;non-custodial Babylon staking&amp;lt;/a&amp;gt; and decentralized governance for the more than $1B of Bitcoin collateral held in Lombard’s protocol, and (2) the &amp;lt;a href=&amp;quot;https://www.coindesk.com/tech/2024/10/16/protocol-village&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;Bascule drawbridge&amp;lt;/a&amp;gt; which enforces secure minting of Lombard’s LBTC on Ethereum. In partnership with the Sui Foundation, Lombard, and Babylon, we are excited to extend all this functionality to Sui and bring LBTC&amp;#x27;s capabilities to the Sui ecosystem.&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; ## Why we are excited about Sui&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; The team building Sui, &amp;lt;a href=&amp;quot;https://www.mystenlabs.com/&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;Mysten Labs&amp;lt;/a&amp;gt;, has deep roots in academic research—like our team&amp;#x27;s work, their efforts span programming languages and security. Indeed, the Move language has many similarities to Rust—the language we use to implement CubeSigner—and uses many ideas from programming languages to eliminate whole classes of vulnerabilities by design. We are excited to bring systems like our Bascule drawbridge to Sui and support teams building secure applications and serious infrastructure in this ecosystem (with a serious key manager 😉).&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; ## Step 0: Hardware-enshrined smart contracts protect Lombard deposits&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; The CubeSigner key management platform has long supported Sui transaction signing, and given Lombard’s success on Ethereum, this is an obvious next step for us to work together to expand support for LBTC on Sui.&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; Lombard users wishing to mint LBTC on Sui will have the same security guarantees as those using Ethereum today. All BTC deposits to the Lombard protocol are protected by &amp;lt;a href=&amp;quot;/blog/a-step-towards-smart-contracts-on-bitcoin&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;hardware-enshrined smart contracts&amp;lt;/a&amp;gt;, which we developed to address Bitcoin’s programmability limitations and bring decentralized security to Bitcoin-based protocol operations. Hardware-enshrined smart contracts are used by decentralized protocols like Lombard to provide the same robust security guarantees as familiar protocols like Ethereum and Sui offer their users, but use secure hardware in addition to consensus for security.&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; &amp;lt;a href=&amp;quot;https://www.lombard.finance/blog/lombard-collaboration-cubist-hardware-enshrined-governance-for-bitcoin-liquid-staking/&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;In Lombard’s case&amp;lt;/a&amp;gt;, hardware-enshrined smart contracts enforce that deposited funds can only be used for Babylon staking (and not be sent to an arbitrary wallet address), and that sensitive governance changes—like updating the contract to change how funds can be used—must be approved by many different parties and are subject to a waiting period. Like &amp;quot;normal&amp;quot; smart contracts, this ensures the protocol controls are decentralized and never in the control of any single person.&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; ## Step 1: Bascule will ensure LBTC minted on Sui is backed by real BTC&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; We built the &amp;lt;a href=&amp;quot;/blog/introducing-the-bascule-drawbridge-for-bitcoin-bridge-security&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;Bascule Drawbridge&amp;lt;/a&amp;gt; to ensure that every LBTC minted on Ethereum is backed by a corresponding BTC deposit on Bitcoin—and prevent losing funds to &amp;lt;a href=&amp;quot;https://arxiv.org/abs/2410.01107&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;the most common types of bridge hacks&amp;lt;/a&amp;gt;. Today, Bascule monitors the Bitcoin chain for BTC deposits to Lombard and reports these deposits to a contract on-chain: the Lombard LBTC contract only mints LBTC if both the Lombard Consortium signed the deposit receipt and Bascule approves the deposit. This ensures there are multiple, independent layers of defense—and each layer takes advantage of both secure hardware and decentralization to provide strong security guarantees.&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; We are excited to extend Bascule to Move—and bring unparalleled bridging security from Bitcoin to the Sui ecosystem! After all, enforcing that each LBTC mint is backed by a BTC deposit is just enforcing &amp;lt;a href=&amp;quot;https://docs.sui.io/concepts/object-ownership#shared&amp;quot; target=&amp;quot;_blank&amp;quot;&amp;gt;ownership&amp;lt;/a&amp;gt; across chains.&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; ## Get ready for Babylon Cap-3&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; Lombard was the largest contributor to Babylon’s Cap-2 in October, taking 30% of the cap with 7,166 BTC staked, and we are proud to have powered the underlying infrastructure that made this possible. We look forward to Cap-3 in December, when BTC holders will be able to deposit their BTC to Lombard for staking on Babylon and receive LBTC natively minted on Sui that they can use for lending, borrowing, and trading across Sui’s DeFi ecosystem.&amp;lt;br&amp;gt; &amp;lt;br&amp;gt; &amp;lt;br&amp;gt;</content>
    <link rel="enclosure" type="image/png" href="https://cdn.prod.website-files.com/638a2693daaf8500030065a2/6744b6499f11887de99e11ee_cubist-babylon-lombard-bring-bitcoin-to-sui-og.png"/>
  </entry>
</feed>
